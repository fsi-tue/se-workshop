<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Software Engineering / Teamprojekt Reference</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="einfuehrung.html">Einf√ºhrung</a></li><li class="chapter-item expanded affix "><a href="terminal.html">Terminal / Shell</a></li><li class="chapter-item expanded affix "><li class="part-title">Git</li><li class="chapter-item expanded "><a href="git/einfuehrung.html"><strong aria-hidden="true">1.</strong> Git?!? Was ist das eigentlich?</a></li><li class="chapter-item expanded "><a href="git/installation.html"><strong aria-hidden="true">2.</strong> Installation und Konfiguration von Git</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="git/installation_windows.html"><strong aria-hidden="true">2.1.</strong> Windows</a></li><li class="chapter-item expanded "><a href="git/installation_macos.html"><strong aria-hidden="true">2.2.</strong> MacOS</a></li><li class="chapter-item expanded "><a href="git/installation_linux.html"><strong aria-hidden="true">2.3.</strong> Linux</a></li></ol></li><li class="chapter-item expanded "><a href="git/how_to_git.html"><strong aria-hidden="true">3.</strong> How to git</a></li><li class="chapter-item expanded "><a href="git/datenmodel.html"><strong aria-hidden="true">4.</strong> Das Datenmodel</a></li><li class="chapter-item expanded "><a href="git/datenmodell_git.html"><strong aria-hidden="true">5.</strong> Datenmodell in Git</a></li><li class="chapter-item expanded "><a href="git/erstes_repository.html"><strong aria-hidden="true">6.</strong> Dein erstes Repository</a></li><li class="chapter-item expanded "><a href="git/staging_working_area.html"><strong aria-hidden="true">7.</strong> Staging und Working Area</a></li><li class="chapter-item expanded "><a href="git/checkout_und_reset.html"><strong aria-hidden="true">8.</strong> Checkout und Reset</a></li><li class="chapter-item expanded "><a href="git/help.html"><strong aria-hidden="true">9.</strong> Help! I fucked up</a></li><li class="chapter-item expanded "><a href="git/branching_und_merging.html"><strong aria-hidden="true">10.</strong> Branching und Merging</a></li><li class="chapter-item expanded "><a href="git/rebase.html"><strong aria-hidden="true">11.</strong> Rebasing</a></li><li class="chapter-item expanded "><a href="git/changing_history.html"><strong aria-hidden="true">12.</strong> Changing History</a></li><li class="chapter-item expanded "><a href="git/tipps_und_tricks.html"><strong aria-hidden="true">13.</strong> Tipps und Tricks</a></li><li class="chapter-item expanded "><a href="git/remotes.html"><strong aria-hidden="true">14.</strong> Remotes</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="git/cheatsheet.html"><strong aria-hidden="true">15.</strong> Cheatsheet</a></li><li class="chapter-item expanded affix "><li class="part-title">Softwareentwicklung</li><li class="chapter-item expanded "><a href="softwareentwicklung.html"><strong aria-hidden="true">16.</strong> Softwareentwicklung</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Software Engineering / Teamprojekt Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="einf√ºhrung"><a class="header" href="#einf√ºhrung">Einf√ºhrung</a></h1>
<p>Willkommen zum Software Engineering Workshop f√ºr Kognitionswissenschaftler! In diesem Workshop erwerbt ihr die theoretischen und praktische Kenntnisse um das Teamprojekt im Rahmen des Informatik-Moduls erfolgreich zu meistern.</p>
<h2 id="workshop-ziele"><a class="header" href="#workshop-ziele">Workshop-Ziele</a></h2>
<p>Wir konzentrieren uns auf folgende Schl√ºsselkomponenten:</p>
<ul>
<li>
<p><strong>Git</strong>: Lerne effektiv mit anderen Entwicklern an einem Softwareprojekt
mittles Git zu arbeiten. Ziel ist das Verst√§ndnis des
zugrundeliegenden Datenmodells, sowie die sichere Anwendung der wichtigsten Befehle.</p>
</li>
<li>
<p><strong>SOLID Design</strong> Prinzipien: Lerne mittles den SOLID-Prinzipien und den
darin enthaltenen Abstraktionsmechanismen qualitativ hochwertigen Code zu schreiben. SOLID ist ein Akronym f√ºr f√ºnf Designprinzipien, die die Erstellung von Software erleichtern und die Wartbarkeit und Erweiterbarkeit des Codes verbessern.</p>
</li>
<li>
<p><strong>Code-Smells</strong>: Lerne g√§ngige &quot;Code Smells&quot; zu erkennen und zu beheben. &quot;Code Smells&quot; sind Anzeichen im Quellcode, die m√∂glicherweise tiefer liegende Probleme signalisieren. Identifiziert und √ºberarbeite schlechten Code, um die Qualit√§t und Lesbarkeit eures Projekts zu verbessern.</p>
</li>
<li>
<p><strong>SCRUM</strong>: Lerne die grundlagen von Agilem Projektmanagement und Scrum. Die Methodik ist weitverbreitet und unterst√ºtzt Teams dabei, in iterativen Sprints effizeint und produktiv zu arbeiten.</p>
</li>
</ul>
<h2 id="zielgruppe-und-vorraussetzungen"><a class="header" href="#zielgruppe-und-vorraussetzungen">Zielgruppe und Vorraussetzungen</a></h2>
<p>Dieser Workshop richtet sich explizit an Kognitionswissenschaftler der Universit√§t T√ºbigen als Vorbereitung f√ºr das Informatik-Teamprojekt. Dementsprechend sind keine spezifischen Vorkenntnisse in der Softwareentwicklung erforderlich. Grundkenntnisse in einer oder mehreren Programmiersprachen jedoch von Vorteil.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminal--shell"><a class="header" href="#terminal--shell">Terminal / Shell</a></h1>
<blockquote>
<p>üí°Wenn du dich schon mit dem Terminal bzw. einer Shell auskennst kannst du diese Seiter √ºberspringen.</p>
</blockquote>
<h2 id="was-ist-das-terminal"><a class="header" href="#was-ist-das-terminal">Was ist das Terminal?</a></h2>
<p>Computer haben heutzutage eine Vielzahl von M√∂glichkeiten bedient zu werden. Sei es √ºber die grafische Benutzeroberfl√§che, Sprachsteuerung oder sogar AR/VR. Diese sind f√ºr 80% der Anwendungsf√§lle gro√üartig, aber sie sind oft in ihren M√∂glichkeiten grundlegend eingeschr√§nkt. Man kann nichts tun, was nicht vorher programmiert wurde. Grade in der Softwareentwicklung sto√üen wir hier an die Grenzen des M√∂glichen. Um die M√∂glichkeiten des Computers voll aussch√∂pfen zu k√∂nnen, m√ºssen wir zur√ºck zu den Anf√§ngen des Computers und eine Textschnittstelle verwenden: Das Terminal.</p>
<blockquote>
<p><strong>Terminal</strong> und <strong>Shell</strong> werden oft synonym verwndet auch wenn sie nicht ganz das gleiche sind. Das <strong>Terminal</strong> ist ein Programm, das es erm√∂glicht, mit einer <strong>Shell</strong> zu interagieren. Die <strong>Shell</strong> ist das eigentliche Programm, das die Befehle ausf√ºhrt.</p>
</blockquote>
<p>In unserem Workshop liegt der Fokus auf der Bourne Again SHell, kurz &quot;bash&quot;. Sie ist eine der am weitesten verbreiteten Shells und ihre Syntax ist √§hnlich zu vielen anderern Shells. Um eine Shell-Prompt zu √∂ffnen (in der du Befehle eingeben kannst), ben√∂tigst du zun√§chst ein Terminal. Auf deinem Ger√§t ist wahrscheinlich bereits eines installiert. (Nutzte auf Windows das Programm &quot;Git Bash&quot;)</p>
<h2 id="die-shell-nutzen"><a class="header" href="#die-shell-nutzen">Die Shell nutzen</a></h2>
<p>Wenn du dein Terminal √∂ffnest, siehst du eine <strong>prompt</strong> die so oder √§hnlich aussieht:</p>
<pre><code class="language-bash">arch:~$
</code></pre>
<p>&quot;arch&quot; ist der Name des Computers, &quot;~&quot; ist das <strong>cwd</strong> (current working directory) bzw. aktuelles Verzeichnis und &quot;$&quot; signalisiert, dass du als normaler Benutzer angemeldet bist. (Adminastrator hat ein &quot;#&quot;).
Das &quot;~&quot; ist eine Abk√ºrzung f√ºr dein Home-Verzeichnis. auf Unix-Systemen ist das <code>/home/deinBenutzername/</code> und auf Windows <code>C:\Users\deinBenutzername\</code>.</p>
<blockquote>
<p>Im Laufe des Workshops werden immer wieder Befehle gezeigt, die du in deinem Terminal ausf√ºhren kannst. Sie haben immer die gleiche Form:</p>
<pre><code class="language-bash">$ cat datei.txt
&gt; Ich bin der Inhalt der Datei!
</code></pre>
<p>Wenn du den Befehl bei dir ausf√ºhren m√∂chtest, must du das <code>$</code> nicht mit eingeben. Es wird nur verwendet um zu zeigen, dass es sich um einen Befehl in der Shell handelt. Hinter dem <code>&gt;</code> steht die Ausgabe des Befehls. In diesem Fall der Inhalt der Datei <code>datei.txt</code>.</p>
</blockquote>
<p>Aber woher wei√ü das Terminal welches Programm es ausf√ºhren soll, wenn du den Behelt <code>cat</code> eingibst? √Ñhnlich zu Programmiersprachen hat auch die Shell ein <strong>Environment</strong>, das Kontext f√ºr die Ausf√ºhrung von Befehlen bereitstellt. In diesem Environment gibt es eine <strong>PATH</strong>-Variable, die eine Liste von Verzeichnissen enth√§lt, in denen die Shell nach Programmen suchen soll. Wenn du also den Befehl <code>cat</code> eingibst, sucht die Shell in den Verzeichnissen, die in der PATH-Variable aufgelistet sind, nach einer Datei namens <code>cat</code> und f√ºhrt sie aus. Solltest du Probleme haben ein Programm im Terminal auszuf√ºhren, auch wenn du dir sicher bist, dass es installiert ist, wurde meistens das Verzeichnis, in dem das Programm liegt, nicht zur PATH-Variable hinzugef√ºgt.</p>
<p>Du kannst die PATH und s√§mtliche anderen Environment-Variablen mit folgendem Befehlt anzeigen lassen:</p>
<pre><code class="language-bash">  $ echo $PATH
  &gt; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</code></pre>
<p>Die Ausgabe schaut bei euch vermutlich √§hnlich aus.</p>
<h3 id="navigation-im-terminal"><a class="header" href="#navigation-im-terminal">Navigation im Terminal</a></h3>
<p>Die Shell liegen die Identischen Verzeichnisse, die auch im Finder / Explorer zu finden sind, zugrunde. Navigation zwischen den einzelnen Verzeichnissen funktioniert √ºber die Befehle <code>cd</code> (change directory) und <code>ls</code> (list). Mit <code>cd</code> kannst du in ein anderes Verzeichnis wechseln und mit <code>ls</code> kannst du dir den Inhalt eines Verzeichnisses anzeigen lassen.</p>
<p>Angenommen du hast folgende Ordnerstruktur:</p>
<pre><code class="language-bash"> +-- ~
     +-- Dokumente
     |   +-- Texte
     |   |   +-- text1.txt
     |   |   +-- text2.txt
     |   +-- Bilder
     |   |   +-- bild1.jpg
     |   |   +-- bild2.jpg
     +-- Downloads
     |   +-- download1.zip
</code></pre>
<p>und du befindest dich in deinem Home-Verzeichnis (<code>~</code>). Wenn du nun sehen willst was sich dort befindet, kannst du den Befehl <code>ls</code> verwenden:</p>
<pre><code class="language-bash">~$ ls
&gt; Dokumente Downloads
</code></pre>
<p>Wenn du hinter <code>ls</code> einen Pfad angibst, wird der Inhalt dieses Verzeichnisses angezeigt. So kannst du zum Beipiel den Ordner Texte anzeigen lassen:</p>
<pre><code class="language-bash">~$ ls Dokumente/Texte
&gt; text1.txt text2.txt
</code></pre>
<p>Um in andere Ordner zu wechseln wir der Beffehl <code>cd</code> verwendet. Wenn du in den Ordner Texte wechseln m√∂chtest, gibst du folgendes ein:</p>
<pre><code class="language-bash">~$ cd Dokumente/Texte
~/Dokumente/Texte$ ls
&gt; text1.txt text2.txt
</code></pre>
<h3 id="absolute-und-relative-pfade"><a class="header" href="#absolute-und-relative-pfade">Absolute und relative Pfade</a></h3>
<p>In unseren vorherigen Beispielen haben wir alle Pfade <strong>relativ</strong> zu deinem aktuellen Verzeichnis angegeben. Das hei√üt, dass der Bezugspunkt immer dein aktuelles Verzeichnis ist. Es gibt aber auch <strong>absolute</strong> Pfade, die immer von der Wurzel des Dateisystems ausgehen. Auf Unix-Systemen ist das <code>/</code> und auf Windows <code>C:\</code>. Wenn du also in deinem Home-Verzeichnis bist und in den Ordner Texte wechseln m√∂chtest, kannst du auch den absoluten Pfad angeben:</p>
<pre><code class="language-bash">~$ cd /home/deinBenutzername/Dokumente/Texte
</code></pre>
<blockquote>
<p>Um den absoluten Pfad zu deinem aktuellen Verzeichnis zu sehen, kannst du den Befehl <code>pwd</code> (print working directory) verwenden.</p>
</blockquote>
<p>Um mit einem relativ zu deinem aktuellen Ordner nach oben zu gehen, kann der Pfad <code>..</code> verwendet werden.</p>
<pre><code class="language-bash">~/Dokumente/Texte$ cd ..
~/Dokumente$
</code></pre>
<p><code>..</code> kann auch in Kombination mit dem bereits bekannten relativen Pfad Syntax verwendet werden. Ein wechsel von <code>Dokumente</code> zu <code>Downloads</code> wird somit recht einfach.</p>
<pre><code class="language-bash">~/Dokumente$ cd ../Downloads
~/Downloads$
</code></pre>
<h3 id="skripte"><a class="header" href="#skripte">Skripte</a></h3>
<p>Wir werden in unserem Workshop nicht n√§her darauf eingehen, jedoch ist es wichtig wenigstens den Begriff zu kennen.</p>
<p>Hinter dem recht unscheinbaren bereits bekannten Shell-Syntax versteckt sich eine Shell-Sprache die viele Features einer vollst√§ndigen Programmiersprache beinhaltet. So existieren Schleifen, if-Bedingungen, etc. B√ºndlet man mehrere Shell-Befehle spricht man von einem Shell-Skript. Diese erm√∂glichen leichte reproduzierbarkeit von komplizierteren T√§tigkeiten und ein einfaches Teilen von Befehlen mit anderen Personen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git---was-ist-das-eigentlich"><a class="header" href="#git---was-ist-das-eigentlich">Git?!? - Was ist das eigentlich?</a></h1>
<p>Stell dir vor, du arbeitest gemeinsam mit einem Team an einem Softwareprojekt.
Jeder arbeitet selbstst√§ndig an seinen Aufgaben und Datein, aber immer wieder
muss alles zusammengef√ºhrt werden, damit alle auf dem neusten Stand sind.</p>
<p>In unserem Beispiel tauscht sich dein Team per E-Mail aus und schickt immer wieder E-Mails mit Dateianh√§ngen hin und her. Bei 2-3 Datein mag das noch gehen, aber sobald es mehr wird, wird es schnell un√ºbersichtlich, kompliziert und fehleranf√§llig.</p>
<h2 id="was-sind-versionsverwaltungssysteme"><a class="header" href="#was-sind-versionsverwaltungssysteme">Was sind Versionsverwaltungssysteme?</a></h2>
<p><strong>Versionierungssysteme</strong> (VCS = Version Control System) sind Werkzeuge, die es erm√∂glichen √Ñnderungen an
Quellcode (oder anderen Sammlungen von Dateien und Ordnern) zu verfolgen.
Dar√ºber hinaus erleichtern sie die Zusammenarbeit mit anderen Entwicklern.
<strong>VCSs</strong> verfolgen Datein und Sub-Ordner in einem ausgew√§hlten Ordner und
speichern von diesen eine Serie von <strong>Snapshots</strong>. Diese enthalten neben den
Datein auch Metadaten, wie zum Beispiel Autoren und assoziierte Nachrichten.</p>
<p>Aber warum ist das n√ºtzlich? Auch wenn du alleine arbeitest, erm√∂glichen dir
<strong>VCSs</strong>, alte Zust√§nde eines Projekts anzusehen, Protokoll zu f√ºhren,
warum bestimmte √Ñnderungen gemacht wurden, parallel an <strong>verschiedenen
Features</strong> zu arbeiten, zu <strong>fr√ºheren Zust√§nden</strong> zur√ºckzuspringen und vieles mehr. Bei der Arbeit mit anderen sind sie ein
unsch√§tzbares Werkzeug, um zu sehen, was andere ge√§ndert haben, sowie um
Konflikte beim <strong>parallelen Bearbeiten</strong> von Datein zu minimieren.</p>
<p>Moderne <strong>VCSs</strong> erm√∂glichen es dir auch leicht (und oft automatisch) Fragen zu beantworten wie:</p>
<ul>
<li>Wer hat dieses Modul geschrieben?</li>
<li>Wann wurde diese bestimmte Zeile dieser speziellen Datei bearbeitet? Von wem? Warum wurde sie bearbeitet?</li>
<li>Im Laufe der letzten 1000 √Ñnderungen, wann und warum hat ein bestimmter Unit-Test aufgeh√∂rt zu funktionieren?</li>
</ul>
<h2 id="alternativen-zu-git"><a class="header" href="#alternativen-zu-git">Alternativen zu Git</a></h2>
<p>W√§hrend Git heute der de fakto Standard ist, gibt es auch andere Systeme, die √§hnliche Funktionen bieten:</p>
<ul>
<li><strong>Mercurial</strong></li>
<li><strong>Subversion (SVN)</strong></li>
<li><strong>Bazaar</strong></li>
</ul>
<p>Jedes dieser Systeme erm√∂glicht √§hnliche Funktionen wie Git, ist aber deutlich
weniger verbreitet und wird in der Regel nur in speziellen Anwendungsf√§llen eingesetzt.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-und-konfiguration-von-git"><a class="header" href="#installation-und-konfiguration-von-git">Installation und Konfiguration von Git</a></h1>
<p>Folgen den Platform-spezifischen Anweisungen um Git auf deinem System zu installieren und komme danach zur√ºck um die Konfiguration abzuschlie√üen.</p>
<ul>
<li><a href="git/./installation_windows.html">Windows</a></li>
<li><a href="git/./installation_macos.html">MacOS</a></li>
<li><a href="git/./installation_linux.html">Linux</a></li>
</ul>
<h1 id="konfiguration"><a class="header" href="#konfiguration">Konfiguration</a></h1>
<p>Die restliche Konfiguration l√§uft analog zu der auf Linux.</p>
<pre><code class="language-bash">$ git config --global user.name &quot;Dein Name&quot;
$ git config --global user.email &quot;deine@email.de&quot;
$ git config --global init.defaultBranch main
$ git config --global color.ui auto
</code></pre>
<p>Verwende hier die Mail-Adresse, die du auch f√ºr deinen Github-Account verwenden wirst / verwendet hast.</p>
<h2 id="github-account"><a class="header" href="#github-account">Github Account</a></h2>
<p>Github ist eine Plattform, auf der Git-Repositories hosted werden k√∂nnen. Was genau das ist lernst du sp√§ter. Hier sei nur gesagt, dass Github nicht das Gleiche wie Git ist und Git auch mit einem anderen Anbieter wie Gitlab oder Bitbucket verwendet werden kann. In unserem Workshop verwenden wir Github.</p>
<p>Erstelle dir nun einen Account auf <a href="git/www.github.com">Github</a>. Verwende die Mail-Adresse, die du auch in der Konfiguration von Git verwendet hast.</p>
<h2 id="ssh-key"><a class="header" href="#ssh-key">SSH-Key</a></h2>
<p>Um Git mit Github zu verbinden, ben√∂tigst du einen SSH-Key. Dieser wird verwendet um dich zu authentifizieren und eine sichere Verbindung zu Github herzustellen. Github stellt hier sehr gute Anleitungen zur Verf√ºgung. Folge den Schritten <a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">hier</a> um einen SSH-Key zu erstellen und den Schritten <a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">hier</a> um diesen zu Github hinzuzuf√ºgen.</p>
<h3 id="verkn√ºfung-testen"><a class="header" href="#verkn√ºfung-testen">Verkn√ºfung testen</a></h3>
<p>Beim ersten Verbinden mit einem neuen Server (z.B. Github) bittet euch ssh, den Schl√ºssel dieses Servers zu √ºberpr√ºfen. Am besten macht ihr das nun f√ºr Github: F√ºhrt den Befehl</p>
<pre><code class="language-sh">ssh -T git@github.com
</code></pre>
<p>aus und akzeptiert den Sch√ºssel mit <code>yes</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-auf-windows"><a class="header" href="#installation-auf-windows">Installation auf Windows</a></h1>
<h3 id="1-git-installieren"><a class="header" href="#1-git-installieren">1. Git installieren</a></h3>
<p>Ladet Euch <a href="https://git-scm.com/download/win">hier</a> den passenden Installer f√ºr euer Windows-Ger√§t herunter und folgt den Anweisungen im Installationsfenster. An den Konfigurationen m√ºsst Ihr nichts √§ndern.</p>
<h3 id="2-konfiguration"><a class="header" href="#2-konfiguration">2. Konfiguration</a></h3>
<p>Folge nun der restlichen Konfiguartion <a href="git/./installation.html#Konfiguration">hier</a></p>
<h3 id="tipps"><a class="header" href="#tipps">Tipps</a></h3>
<p>Wenn ihr Windows benutzt und euch gewundert habt, warum ihr keine Dateien mit &quot;.&quot;-Pr√§fix seht (z.B. &quot;.git&quot;, &quot;.gitconfig&quot;, etc.) bzw. mit &quot;.&quot;-Suffix (z.B. &quot;.txt&quot;, &quot;.mp4&quot;, etc.), dann k√∂nnt ihr das folgenderma√üen √§ndern:</p>
<ol>
<li>
<p>Sucht nach den &quot;Explorer-Optionen&quot; (entweder √ºber das Suchfeld in den Einstellungen oder indem ihr mit dem Rechtsklick auf den Explorer klickt und auf &quot;Eigenschaften&quot; klickt).</p>
</li>
<li>
<p>Klickt in dem neu ge√∂ffneten Fenster auf den Reiter &quot;Ansicht&quot;</p>
</li>
<li>
<p>Deaktiviert &quot;Erweiterungen bei bekannten Dateitypen ausblenden&quot;</p>
</li>
<li>
<p>Wechselt die Option von &quot;Ausgeblendete Dateien, Ordner oder Laufwerke nicht anzeigen&quot; zu &quot;Ausgeblendete Dateien, Ordner oder Laufwerke anzeigen&quot;</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-auf-macos"><a class="header" href="#installation-auf-macos">Installation auf MacOS</a></h1>
<h2 id="homebrew"><a class="header" href="#homebrew">Homebrew</a></h2>
<p>Falls noch nicht der inoffiziellen (aber sehr verbreitete) Paketmanager <a href="https://brew.sh/">homebrew</a> auf deinem MacBook installiert ist, ist jetzt der Zeitpunkt. <code>brew</code> erm√∂glicht die einfache Installation von Software und wird dir noch oft in der Entwicklung auf MacOS begegnen.j</p>
<p>Die Installation ist sehr simple. Kopiere den folgenden Befehl in dein Terminal und folgen den angezeigten Anweisungen.</p>
<pre><code class="language-bash">$ /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
</code></pre>
<blockquote>
<p>Das <code>$</code> Zeichen wird verwendet um zu signalisieren, dass der folgende Befehl im Terminal auszuf√ºhren ist und ist nicht Teil des Befehls.</p>
</blockquote>
<h2 id="git"><a class="header" href="#git">git</a></h2>
<ol>
<li>
<p>Intalliere nun git mittels <code>brew</code>:</p>
<pre><code class="language-bash">$ brew install git
</code></pre>
</li>
<li>
<p>Folge nun der restlichen Konfiguartion <a href="git/./installation.html#Konfiguration">hier</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-auf-linux"><a class="header" href="#installation-auf-linux">Installation auf Linux</a></h1>
<blockquote>
<p>üí° In Linux (Ubuntu) √∂ffnet man am schnellsten ein Terminal mit <code>Strg</code> + <code>Alt</code> + <code>T</code>. Auf andern Distributionen kann das abweichen.</p>
</blockquote>
<h3 id="1-git-installieren-1"><a class="header" href="#1-git-installieren-1">1. Git installieren</a></h3>
<p>Git kann √ºber den Paketmanager der jeweiligen Distribution installiert werden. Der Befehl lautet also auf Debian-basierten Systemen wie Ubuntu oder Linux Mint:</p>
<pre><code class="language-bash">$ sudo apt-get install git
</code></pre>
<blockquote>
<p>üí° Das <code>$</code> Zeichen wird verwendet um zu signalisieren, dass der folgende Befehl im Terminal auszuf√ºhren ist und ist nicht Teil des Befehls.</p>
</blockquote>
<p>Eine Liste mit dem Installationsbefehl f√ºr eine gro√üe Menge an anderen Distributionen findet sich <a href="https://git-scm.com/download/linux">hier</a> auf der offiziellen Website von Git.</p>
<h3 id="2-konfiguration-1"><a class="header" href="#2-konfiguration-1">2. Konfiguration</a></h3>
<p>Folge nun der restlichen Konfiguartion <a href="git/./installation.html#Konfiguration">hier</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-git"><a class="header" href="#how-to-git">How to git</a></h1>
<p>Git wird oftmals als ein unsch√∂nes aber leider notwendiges Tool zur Kollaboration mit anderen gesehen. Viele unterstellen git extreme Komplexit√§t und ein schwieriges User Interface. Das f√ºhrt manchmal zu der unten Dargestellten bizzaren Situation.</p>
<p><img src="git/./git_meme.png" alt="Meme" /></p>
<p>Ziel unseres Workshops ist es, dass dir diese Situation nicht passiert. Du wirst nicht nur Shell-Befehle lernen, sondern vielmehr die zugrundeliegenden Mechanismen verstehen. Wenn du die inneren Mechansimen verstehst wird auch das Interface einfacher und deutlich intuitiver zu verstehen werden.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datenmodel"><a class="header" href="#datenmodel">Datenmodel</a></h1>
<p>Es gibt viele verschieden Ans√§tze f√ºr die ein VCS zu implementieren. Git verwendet ein sehr einfaches aber durchdachtes Modell, dass uns erm√∂glicht Features wie Branches, Kollaboration und eine Dateihistorie zu nutzten</p>
<h1 id="snapshots--commits"><a class="header" href="#snapshots--commits">Snapshots / Commits</a></h1>
<p>Unser Modell beinhaltet einer Sammlung von Ordnern und Datein in einem &quot;top-level&quot; Ordner - ein Snapshot auch <strong>Commit</strong> genannt. Von git wird eine Datei auch als <code>blob</code> bezeichnet und ist letzendlich nur eine Sammlung aus Bytes. Das Dateiformat spielt somit keine Rolle. Ein Ordner wird als <code>tree</code> bezeichnet und ordnet einem Namen einen oder mehrere <code>blob</code>s und andere <code>tree</code>s zu. Ordner k√∂nnen dementsprechend andere Ordner oder Datein enthalten und sind identisch vom Aufbau zu unserem Dateisystem. Zum Beispiel:</p>
<pre><code>&lt;root&gt; (tree)
|
+- beispiel (tree)
|  |
|  + hello.txt (blob, contents = &quot;hello world&quot;)
|
+- inhalt.txt (blob, contents = &quot;git ist super&quot;)
</code></pre>
<p>Der top-level <code>tree</code> referenziert den <code>tree</code> &quot;beispiel&quot; (der wiederum einen <code>blob</code> enh√§lt) und den <code>blob</code> &quot;inhalt.txt&quot;.</p>
<h1 id="snapshots-in-relation"><a class="header" href="#snapshots-in-relation">Snapshots in Relation</a></h1>
<p><strong>Snapshots</strong> alleine bringen uns noch keinen Mehrwert. Erst wenn wir mehrere Snapshots in Relation setzten, kommen wir unserem Ziel eines VCS n√§her.</p>
<h2 id="version-history-versionsgeschichte"><a class="header" href="#version-history-versionsgeschichte">Version history (Versionsgeschichte)</a></h2>
<p>Widmen wir uns zuerst der wichtigsten Annforderung an unser Modell - der Versionsgeschichte. Zu jedem Zeitpunkt wollen wir √Ñnderungen an unseren Dateinen nachverfolgen und falls n√∂tig R√ºckg√§ngig machen k√∂nnen. Das einfachste Modell ist die zeitliche Anneinanderreihung unserer Snapshots. Wir erhalten Modell mit einer rein linearen Relation.</p>
<pre><code>o &lt;--- o &lt;--- o &lt;--- o &lt;--- o
</code></pre>
<p>Jedes <code>o</code> symbolisiert hier einen Snapshot und jeder <code>&lt;---</code> eine Parent-Child-Relation. Das Child zeigt hierbei immer auf den Parent.</p>
<p>Sollten wir nun eine √Ñnderung vorgenommen haben, die wir R√ºckg√§ngig machen wollen. Suchen wir vom letzten (rechten) Snapshot in den Parent Snapshots (von rechts nach links), bis wir einem Snapshot gefunden haben, der unsere Datei im gew√ºnschten Zustand enth√§lt. Den Inhalt k√∂nnen wir kopieren und in unserem aktuellen Snapshot einf√ºgen.</p>
<p>Eine Version History ist somit m√∂glich.</p>
<h2 id="branches"><a class="header" href="#branches">Branches</a></h2>
<p>Softwareprojekte werden selten in Isolation geschrieben. W√§hrend Person A an dem einen Feature arbeitet, schreibt Person B vielleicht an einem anderen. Dies bringt Probleme mit sich, die wir in unserem aktuellen Modell nicht l√∂sen k√∂nnen. Schauen wir uns ein Beispiel an:</p>
<p>Am Angang haben wir einen Commit (Snapshot) der leeren Datei src/datei.txt.
Dann arbeiten Alice und Bob parallel an dieser:</p>
<p>Alice in src/datei.txt:</p>
<pre><code>fn hello_world() {
   print(&quot;Hello World&quot;)
}

fn main() {
   hello_world()
}
</code></pre>
<p>Bob in src/datei.txt:</p>
<pre><code>fn hello(name: String) {
   print(&quot;Hello&quot; + name)
}

fn main() {
   hello(&quot;Bob&quot;)
}
</code></pre>
<p><code>src</code>ist unser <code>top-level</code>-Ordner.
Beide Personen schreiben an der selben Datei. Nur die Inhalte sind leicht unterschiedlich. Alice will das klassiche &quot;Hello World&quot; ausgegeben, w√§hrend Bob lieber den eine Begr√º√üung mit Namen ausgeben m√∂chte. Wir gehen davon aus dass sich nur diese Datei in dem Ordner <code>src</code> befindet. Wenn somit beide einen Commit (=Snapshot) erstellen haben diese die Form:</p>
<pre><code>src (tree)
|
+- datei.txt (blob, contents = ...)
</code></pre>
<p>Aber wie sollen wir beide in Relation setzten? Unser bisheriges Modell hat sich an die zeitliche Reihenfolge gehalten. Der Commit mit der leeren Datei kommt somit zuerst, aber was ist mit den anderen beiden? Wenn Bob nach Alice seine Commit erstellt, wird Alice ihre Arbeit √ºberschrieben. Wenn Alice nach Bob commited ist es genau anders herum. Paralleles Arbeiten ist somit noch nicht m√∂glich.</p>
<h3 id="paralleles-modell"><a class="header" href="#paralleles-modell">Paralleles Modell</a></h3>
<p>Die Zeit war bis jetzt unsere x-Achse und wenn wir eine sinnvolle Version History behalten wollen, sollten wir das auch nicht √§ndern. Alice und Bob arbeiten aber parallel an ihren Features. Wir wollen also wenn m√∂glich eine zeitlich √§quivalente Einordnung von beiden Commits. Warum nicht einfach √ºbereinander?</p>
<pre><code>o &lt;--- o (Alice)
  ^
   \
    -- o (Bob)
</code></pre>
<p>Der erste Commit bleibt unver√§ndert. Alice und Bobs Commits werden aber nicht mehr in eine Parent-Child Relation gebracht, sondern sind vielmehr in einer Sibling Relation. Beide haben als Parent den gleichen ersten Commit.</p>
<p>Die Struktur unseres Modells √§ndert sich also von einer reinen linearen Aneinanderreihung zu einem <strong>Baum</strong>. Paralleles Arbeiten wird somit m√∂glich und Alice und Bob kommen sich nicht mehr in die Quere. Diese unterschiedlichen Str√§nge werden in git als <strong>Branches</strong> bezeichnet.</p>
<blockquote>
<p>Wen du schon Algorithmen geh√∂rt hast, wird dir das bekannt vorkommen. Falls nicht ist auch nicht schlimm. Ein <strong>Baum</strong> besteht aus lauter <strong>Knoten</strong> (hier: Commits) die genau einen <strong>Parent</strong> haben. Ein <strong>Knoten</strong> kann aber mehrere <strong>Kinder</strong> haben. Also wie ein Baum in der Natur, nur dass wir ihn meistens um 90¬∞ oder 180¬∞ gedreht darstellen.</p>
</blockquote>
<p>Aktuell haben wir unsere <strong>Branches</strong> nach den Namen der Personen benannt, aber in der Praxis benennen wir sie nach den Features an denen wir arbeiten. Also lass uns die Namen √§ndern:</p>
<pre><code>o-1 &lt;--- o-2 (feature_a)
  ^
   \
    -- o-3 (feature_b)
</code></pre>
<p>Damit wir einfacher Commits referenzieren k√∂nnen, haben wir ihnen eine Nummer gegeben. Die Reihenfolge der Nummern spielt dabei keine Rolle, sondern ist nur zur Unterscheidung gedacht. Git verwendet statt Nummern Hashes mehr dazu aber sp√§ter.</p>
<p>Aus Perspektive von Branch <code>feature_a</code> existieren nur zwei Commits o-1 und o-2. Von Branch <code>feature_b</code> existier Commit o-1 und o-3.</p>
<blockquote>
<p>‚ÄºÔ∏è Commits k√∂nnen nur existieren, wenn sie von einem Branch direkt oder indirekt referenziert werden. Ein Commit der von keinem Branch referenziert wird, wird von git als <strong>unreachable</strong> bezeichnet und nach einer gewissen Zeit gel√∂scht.</p>
</blockquote>
<blockquote>
<p>Branch Namen m√ºssen eindeutig sein und d√ºrfen keine Leerzeichen enthalten. Die Namen m√ºssen keinen Konventionen folgen, es ist aber ratsam sich auf eine gemeinsame Konvention im Team zu einigen.</p>
</blockquote>
<h1 id="merging-branches"><a class="header" href="#merging-branches">Merging Branches</a></h1>
<p>Wir haben nun zwei Branches die parallel an ihren Features arbeiten. Aber wie k√∂nnen wir den Fortschritt von beiden zusammenf√ºhren? Warum nicht einfach die Commits und damit auch √Ñnderungen von beiden Branches in einen Commit zusammenfassen?</p>
<pre><code>o-1 &lt;--- o-2 &lt;--- o-4 (feature_a, feature_b)
  ^              /
   \            /
    -- o-3 &lt;---
</code></pre>
<p>Hier erstellen wir einen neuen Commit (o-4) der zwei Parents besitzt: o-2 und o-3. Dieser Commit enth√§lt somit die √Ñnderungen von beiden Branches. Diese M√∂glichkeit Branches zusammenzuf√ºhren wird in git als <strong>Merge</strong> bezeichnet.</p>
<p>Unser Modell m√ºssen wir somit erweitern. Ein Knoten / Commit in einem Baum kann immer nur ein Parent erhalten. Unser Merge-Commit o-4 hat aber zwei Parents. In der Graphentheorie nennen wir diese neue Struktur einen <strong>DAG</strong> (Directed Asyclic Graph). Es hat nur eine wichtige Eigenschaft: Es gibt keine Zyklen. Das bedeutet, wenn wir den Verbindungen (Relations / Pointern) folgen, werden wir nie wieder an den selben Knoten zur√ºckkommen.</p>
<p>So sch√∂n und unkompliziert das Merging in der Theorie klingt, ist es in der Praxis leider nicht immer. Auch wenn git recht intelligent mit dem Zusammenf√ºhren von √Ñnderungen umgeht, kann es immer noch zu Konflikten kommen, die dann manuell gel√∂st werden m√ºssen. Hier fokusieren wir uns erstmal auf die Theorie und lernen sp√§ter wie wir mit Konflikten umgehen.</p>
<h1 id="rebasing-branches"><a class="header" href="#rebasing-branches">Rebasing Branches</a></h1>
<p>Das einfache Zusammenf√ºhren von Branches ist nicht die einzige M√∂glichkeit √Ñnderungen von der einen Branch mit der andern zu kombinieren. Git erlaubt uns auch das einfache &quot;anh√§ngen&quot; von Commits aus einem Branch an einen anderen. Der Vorgang wird als <strong>Rebase</strong> bezeichnet.</p>
<p>Wenn wir nun also die Commits von Branch <code>feature_b</code> an Branch <code>feature_a</code> anh√§ngen wollen, ver√§ndert sich unser Commit-Graph wie folgt:</p>
<pre><code>o-1 &lt;--- o-2 (feature_a)
  ^
   \
    -- o-3 (feature_b)

== (rebase feature_a feature_b) ==

o-1 &lt;--- o-2 (feature_a)
           ^
            \
             -- o-3 (feature_b)
</code></pre>
<p><code>feature_a</code> besteht nun aus den Commits o-1 und o-2, w√§hrend <code>feature_b</code> nun aus o-1, o-2 und o-3 besteht. <code>feature_a</code> ver√§ndert sich somit nicht.
Auch hier kann es selbstverst√§ndlich zu Konflikten kommen, die manuell gel√∂st werden m√ºssen. Dazu sp√§ter mehr.</p>
<h1 id="commits"><a class="header" href="#commits">Commits</a></h1>
<p>Du hast Commits bereits als &quot;Snapshots&quot; deiner Datein kennengelernt, dass ist nicht falsch, aber auch nicht ganz vollst√§ndig. Zus√§tzlich zu dem Zustand deiner Datein, speichert ein Commit noch Metainformationen wie:</p>
<ul>
<li>Autor</li>
<li>Nachricht</li>
<li>Zeitstempel</li>
</ul>
<p>Commits sind immutable. Das bedeutet, dass √Ñnderungen an alten Commits immer zwangsweise einen neuen Commit erstellen. Ohne diese Eigenschaft h√§tten wir keine klar nachfolziehbare Version History.</p>
<blockquote>
<p>Jedes Mal den vollst√§ndingen Datei-Tree zu speichern ist nicht nur ineffizient, sondern auch unn√∂tig. Um das zu verhindern, werden gleiche Dateien und Verzeichnissse nur einmal gespeichert und sind dann von mehreren Commits referenzierbar. Eine einfache Implementierung dieser Optimierung ist durch die Immutablilty der Commits m√∂glich.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datenmodell-in-git"><a class="header" href="#datenmodell-in-git">Datenmodell in Git</a></h1>
<h1 id="commit-hashes"><a class="header" href="#commit-hashes">Commit Hashes</a></h1>
<p>Unser Datenmodell von der letzten Seite ist schon recht fortschrittlich, jedoch gibt es im Bezug zu git noch ein paar kleine Unterschiede. Bisher haben wir Commits der Einfachkeit halbar mit o-x bezeichnet. In git werden Commits jedoch mit Hashes referenziert. Ein Hash ist eine Art Fingerabdruck eines Objekts. Der Hash eines Objekts ist immer gleich, solange sich das Objekt nicht ver√§ndert. Git hat sich f√ºr einen SHA-1 Hash entschieden, der 40 Hexadezimalzeichen lang ist. Da diese jedoch extrem unterschiedlich sind, reicht es meistens nur die ersten 7 Zeichen zu verwenden.</p>
<p>So schaut zum Beispiel der Hash des eines Commits von diesem Buch aus:</p>
<pre><code>$ git rev-parse HEAD
&gt; 9af8a075faebfc5391a1caf52116fc2cd45b2a13
</code></pre>
<p>Es reichen aber die ersten 7 Zeichen:</p>
<pre><code>$ git rev-parse --short HEAD
&gt; 9af8a07
</code></pre>
<p>So k√∂nnen wir das Beispiel von vorhin auch mit Hashes darstellen:</p>
<pre><code>o-1 &lt;--- o-2 (feature_a)
  ^
   \
    -- o-3 (feature_b)

== wird zu ==
9af8a07 &lt;--- 3b2e1a2 (feature_a)
  ^
   \
    -- 1a2b3c4 (feature_b)
</code></pre>
<p>Die Hashes sind hierbei komplett zuf√§llig und dienen nur zur Veranschaulichung.</p>
<h1 id="head"><a class="header" href="#head">HEAD</a></h1>
<p>Bisher haben wir uns immer nur das gro√üe ganze angeschaut, uns aber noch nicht √ºberlegt wie wir auf die unterschiedlichen Commits bzw. Branches zugreifen k√∂nnen. Hier kommt der <strong>HEAD</strong> ins Spiel. Der HEAD ist ein Pointer auf einen beliebigen Commit oder Branch. Wenn wir also den Inhalt von <code>feature_a</code> anschauen wollen, setzten wir den HEAD auf <code>feature_a</code> und k√∂nnen dann den Inhalt von <code>feature_a</code> betrachten. Selbiges funktioniert mit <code>feature_b</code> oder anderen beliegibigen Branches. Da die meisten Operationen in git relativ zu HEAD arbeiten ist es wichtig zu wissen, wo dieser sich grade befindet. Wir f√ºgen also noch HEAD in unser Datenmodell ein:</p>
<pre><code>9af8a07 &lt;--- 3b2e1a2 (feature_a)
  ^                     ^
   \                    HEAD
    -- 1a2b3c4 (feature_b)
</code></pre>
<p>Hier ist HEAD auf <code>feature_a</code> gesetzt.</p>
<h1 id="besonderheiten-von-branches"><a class="header" href="#besonderheiten-von-branches">Besonderheiten von Branches</a></h1>
<p>Bisher haben wir Branches nur sehr intuitiv definiert gehabt. Jeder Ast hat einfach einen Namen bekommen. Aber was genau ist ein Branch?</p>
<p>Ein Branch ist √§hnlich wie HEAD ein Pointer auf einen Commit. Der Unterschied l√§sst sich gut an einem Beispiel festmachen:</p>
<p>Wir nehmen an du wanderst gerne durch die Alpen. Auf deiner heutigen Wanderung plannst du zwei Gipfel zu besteigen. Du startest also am Parkplatz und wanderst zum ersten Gipfel. Dort angekommen, machst du eine Pause und genie√üt die Pause bevor es weiter zum zweiten Gipfel geht.</p>
<p>Die Gipfelkreuze mit ihren Bergnamen sind die Branches und du als Wanderer bist der HEAD. Auch HEAD sieht immer nur aus seiner eigenen Perspektive und f√ºhrt alle Aktionen relativ dazu aus.</p>
<p>Der Berg selber sind die Commits. Berge wachsen √ºber die Zeit und werden immer ein bischen h√∂her. Das Gipfelkreuz bleibt aber immer oben auf dem Berg. Wenn du also einen neuen Commit unserem Branch hinzuf√ºgst, w√§chst der Berg und das Gipfelkreuz wird ein St√ºck h√∂her.</p>
<h1 id="tags"><a class="header" href="#tags">Tags</a></h1>
<p>Schauen wir uns nochmal unsere Wanderung an. Wir folgen unserem Weg und kommen an einem besonders sch√∂nen Aussichtspunkt vorbei. Hier machen wir ein Foto mit unserem Handy. Die Geodaten von dem Punkt werden gleich mitgespeichert. Wenn wir also sp√§ter das Foto anschauen, k√∂nnen wir genau sehen wo wir waren und mit einer Karte auch einfach wieder zur√ºckfinden. <strong>Tags</strong> in git sind √§quivalent zu diesem Foto. Sie sind ein Pointer auf einen bestimmten Commit damit wir diesen sp√§ter einfach wieder finden k√∂nnen. Wir markieren damit zum Beispiel wichtige Releases oder Meilensteine. Da Tags namen besitzten k√∂nnen sind sie deutlich einfachere Referenzen als die komplizierten Hashes der Commits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dein-erstes-repository"><a class="header" href="#dein-erstes-repository">Dein erstes Repository</a></h1>
<p>Jetzt haben wir gen√ºgend Theorie f√ºr den Anfang. Lass uns ein Repository erstellen und damit arbeiten. Repositroy nennt man ein Verzeichnis, das von Git getrackt wird. Hier sind alle Funktionen des VCS verf√ºgbar.</p>
<h2 id="repository-erstellen"><a class="header" href="#repository-erstellen">Repository erstellen</a></h2>
<ol>
<li>
<p>Erstelle zun√§chst ein neues Verzeichnis f√ºr dein Repository.
Navigiere mit <code>cd</code> in das Verzeichnis, wo du das Repository erstellen m√∂chtest.</p>
<pre><code class="language-bash"> $ cd ~/dev
</code></pre>
<p>Bei mir ist das der Ordner <code>dev</code> in meinem Home-Verzeichnis.
erstelle ein neues Verzeichnis mit <code>mkdir</code>.</p>
<pre><code class="language-bash"> $ mkdir my_repository
</code></pre>
<p>mit <code>ls</code> kannst du √ºberpr√ºfen, ob das Verzeichnis erstellt wurde.</p>
<pre><code class="language-bash"> $ ls
 &gt; my_repository ...
</code></pre>
</li>
<li>
<p>Jetzt machen wir aus dem Verzeichnis ein Git-Repository.
Navigiere jetzt in das Verzeichnis.</p>
<pre><code class="language-bash"> $ cd my_repository
</code></pre>
<p>und f√ºhre den Befehl <code>git init</code> aus. Das initialisiert das Repository.</p>
<pre><code class="language-bash">  $ git init
  &gt; Initialized empty Git repository in ~/dev/my_repository/.git/
</code></pre>
<p>Achte auf das Ende das Ausgabe. Es zeigt an, dass ein neues verstecktes Verzeichnis <code>.git</code> erstellt wurde. Das ist das Verzeichnis, in dem Git alle Informationen √ºber das Repository speichert. Wenn du dieses Verzeichnis l√∂scht, sind auch alle Informationen √ºber das Repository weg und nur dein aktueller HEAD Zustand bleibt erhalten.</p>
<blockquote>
<p>Wenn es dich interessiert, wie das Verzeichnis aussieht und wie genau Git deine Daten speichert, kannst du <a href="https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain">hier</a> mehr dar√ºber lesen.</p>
</blockquote>
<p>Wir haben jetzt erfolgreich ein neues Repository erstellt. Um zu √ºberpr√ºfen, ob alles geklappt hat, f√ºhre den Befehl <code>ls -a</code> aus. Das zeigt dir alle versteckten Dateien und Verzeichnisse an.</p>
<pre><code class="language-bash"> $ ls -a
 &gt; . .. .git
</code></pre>
</li>
</ol>
<h1 id="repository-clonen"><a class="header" href="#repository-clonen">Repository clonen</a></h1>
<p>Ein neues Repository erstellen ist oftmals hilfreich, ist aber nicht der normalfall. Meistens arbeiten wir an Projekten die von anderen bereits begonnen wurden. Um ein Repository von einem Remote zu kopieren, verwenden wir die <code>git clone</code> Funktion. Was genau ein Remote ist, lernst du sp√§ter. Hier sei nur gesagt, dass ein Remote ein anderes Repository ist, das auf einem anderen Server liegt. Das kann z.B. Github sein.</p>
<p>Wir klonen nun ein bereits bestehendes Repository von Github. Dazu suchen wir uns erst ein passendes Repository raus. Ich nehme hier ein f√ºr unseren Workshop erstelltes <a href="https://github.com/leonfuss/se_workshop_example">Repository</a>. Wir haben immer die wahl zwischen einen SSH und einem HTTP clone. Solltest du selber an einem Projekt arbeiten wollen, empfehle ich dir den SSH clone. Ansonsten wird es sp√§ter schwierig, wenn du deine √Ñnderungen wieder zur√ºck an den Server schicken m√∂chstet.</p>
<pre><code class="language-bash"> $ git clone git@github.com:leonfuss/se_workshop_example.git
 &gt; Cloning into 'se_workshop_example'...
 remote: Enumerating objects: 25, done.
 remote: Counting objects: 100% (25/25), done.
 remote: Compressing objects: 100% (13/13), done.
 Receiving objects: 100% (25/25), 6.34 KiB | 6.34 MiB/s, done.
 Resolving deltas: 100% (6/6), done.
 remote: Total 25 (delta 6), reused 22 (delta 6), pack-reused 0
</code></pre>
<p>Danach haben wir einen Ordner <code>se_workshop_example</code> erstellt, der das Repository enth√§lt. Solltest du das Repository woanders haben wollen, kannst du alternativ auch den Pfad angeben.</p>
<pre><code class="language-bash"> $ git clone git@github.com:leonfuss/se_workshop_example.git /pfad/zu/deinem/ordner
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="staging-und-working-area"><a class="header" href="#staging-und-working-area">Staging und Working Area</a></h1>
<p>Bis jetzt hat unser Datenmodell sowie unser frisch erstelltes Repository noch keinen Bezug zu unseren &quot;normalen&quot; Dateien, so wie wir sie aus unserem Finder oder Explorer kennen. Wir kennen unseren Commit Tree und unser Dateisystem, aber wie stehen diese miteinander in Interaktion?</p>
<h2 id="working-area-working-tree"><a class="header" href="#working-area-working-tree">Working Area (Working Tree)</a></h2>
<p>Das ganz normale Dateisystem in git wird auch als Working Area bezeichnet. Wie der Name bereits indikiert, ist dies der Bereich, in dem wir wie gewohnt arbeiten. Wir erstellen Datein, l√∂schen Datein, √§ndern Datein, etc. Hier ist also nahezu alles gleich - mit oder ohne git.</p>
<h2 id="staging-area"><a class="header" href="#staging-area">Staging Area</a></h2>
<p>Jetzt k√∂nnten wir, um unser Commit Tree zu integrieren einfach alle Datein in unserem Working Directory zu bestimmten Zeitpunkten als Commit unserem Datenmodell hinzuf√ºgen. An sich ist daran nichts falsch, jedoch ist es nicht besonders flexibel. Was wenn wir nur Teile unserer Datein committen also zu einem bestimmten Zeitpunkt festhalten wollen. Oder nur bestimmte √Ñnderungen in einer Datei festgehalten werden sollen.
Hier kommt die Staging Area ins Spiel. Die Staging Area ist wie ein Warenkorb beim Onlineshopping. Wir k√∂nnen Sachen rein legen und wieder rausnehme, wenn wir uns doch unsicher sind. Und erst wenn wir sicher sind, dass wir alles haben was wir wollen, gehen wir mit unserem Warenkorb zur Kasse (dem finalem Commit erstellen). Wir haben also die M√∂glichkeit nochmals zu √ºberpr√ºfen, ob wir genau das wollen was wir haben.</p>
<p>Um unseren Datein aus der Working Area in den Warenkorb - die Staging Area - zu legen, verwenden wir den Befehlt <code>git add</code>.</p>
<p>Schauen wir uns das an einem Beispiel an:</p>
<pre><code class="language-bash">+-- my_git_repo
    +-- .git/...
    +-- src
    |   +-- foo
    |   |   +-- foo.txt
    |   |   +-- bar.txt
    +-- config.toml
</code></pre>
<p>Der <code>.git</code> Ordner ist schon vorhanden. Unser Ordner ist allso schon ein git Repository. Wir haben bereits ein paar leere Datein erstellt und bis jetzt noch nichts unserem commit tree hinzugef√ºgt.
Wir k√∂nnen das sehr sch√∂n √ºberpr√ºfen, indem wir uns den aktuellen Status des Repositories anzeigen lassen:</p>
<pre><code class="language-bash">$ git status
&gt; On branch main

  No commits yet

  Untracked files:
    (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
	  config.toml
	  src/

  nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</code></pre>
<p>Was sehen wir hier? Es existiert der Branch <code>main</code> und unser HEAD befindet sich akutell dort. Jedoch gibt es noch keinen Commits in unserem Repository.</p>
<p>Git zeigt uns aber schon an, dass es Datein gibt, die noch nicht getrackt - noch nie in einem Commit festgehalten - wurden</p>
<blockquote>
<p>Die Empfehlungen die git uns gibt, finden sich in nahe zu jeder Ausgabe von git und sind oft genau dass was wir machen wollen. Es lohnt sich also, diese zu lesen.</p>
</blockquote>
<p>Um unsere Datein zu tracken, m√ºssen wir sie zuerst unserer Staging Area hinzuf√ºgen:</p>
<pre><code class="language-bash">  $ git add config.toml
  $ git add src/
</code></pre>
<p>Beim ersten <code>add</code> f√ºgen wir nur <code>config.toml</code> hinzu. Beim zweiten <code>add</code> f√ºgen wir den gesamten Ordner <code>src/</code> sammt aller Datein hinzu. Alternativ k√∂nnen wir das auch als ein Befehl schreiben:</p>
<pre><code class="language-bash">  $ git add config.toml src/
</code></pre>
<blockquote>
<p>Theoretisch k√∂nnen wir auch sehr simple alle √Ñnderungen und Datein der Staging Area hinzuf√ºgen:</p>
<pre><code class="language-bash">  $ git add .
</code></pre>
<p>Auch wenn das kurzfristig sehr praktisch aussieht, w√ºrde ich davon abraten. Sehr oft geraten dabei Datein in die Staging Area und in den darauffolgenden Commit, die nicht da sein sollten. Was genau in einen Commit sollte schauen wir uns sp√§ter im Kontekt der Softwareentwicklung an.</p>
</blockquote>
<p>Wenn wir jetzt nochmal den Status unseres Repositories abfragen schaut das ein wenig anders aus:</p>
<pre><code class="language-bash">$ git status
&gt; On branch main

  No commits yet

  Changes to be committed:
    (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)
	  new file:   config.toml
	  new file:   src/foo/bar.txt
	  new file:   src/foo/foo.txt
</code></pre>
<p>Unter <code>Changes to be committed</code> sehen wir jetzt die Datein, die wir gerade der Staging Area hinzugef√ºgt haben.</p>
<h1 id="commit"><a class="header" href="#commit">Commit</a></h1>
<p>Der einzige Schritt der jetzt noch fehlt ist alle √Ñnderungen von der Staging Area in einen Commit zu √ºberf√ºhren. Das machen wir mit dem Befehl <code>git commit</code>. Sei dabei sicher, dass du nur Datein in der Staging Area haben m√∂chtest, die auch wirklich in den Commit sollen.
In unserem Fall m√∂chten wir alle neu erstellten Datein in den Commit packen.</p>
<pre><code class="language-bash">$ git commit
&gt; [main (root-commit) 3adf051] Initial commit
 3 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 config.toml
 create mode 100644 src/foo/bar.txt
 create mode 100644 src/foo/foo.txt
</code></pre>
<p>Nachdem ihr den Befehl ausgef√ºhrt habt, √∂ffnet sich ein Editor. Hier k√∂nnt ihr eine Commit Message schreiben. Diese sollte kurz und pr√§gnant sein und beschreiben, was ihr in diesem Commit gemacht habt. Wenn ihr den Editor schlie√üt, wird der Commit erstellt. Solltet ihr nur eine kurze Nachricht haben k√∂nnen wir diese auch direkt in der Shell hinzuf√ºgen:</p>
<pre><code class="language-bash">  $ git commit -m &quot;Initial commit&quot;
  &gt; [main (root-commit) 3adf051] Initial commit
   3 files changed, 0 insertions(+), 0 deletions(-)
   create mode 100644 config.toml
   create mode 100644 src/foo/bar.txt
   create mode 100644 src/foo/foo.txt

</code></pre>
<p>Wenn wir jetzt den Status unseres Repositories abfragen ist die Ausgabe deutlich k√ºrzer:</p>
<pre><code class="language-bash">$ git status
&gt; On branch main
  nothing to commit, working tree clean
</code></pre>
<p>Unsere Staging Area ist leer und in unserer Working Area (working tree) gibt es keine √Ñnderungen im Vergleich zum letzten Commit.</p>
<pre><code class="language-mermaid">sequenceDiagram
   Working Tree -&gt;&gt; Staging Area: git add &lt;file&gt;
   Staging Area -&gt;&gt; Commit Tree: git commit
   Commit Tree --&gt;&gt; Working Tree: git checkout
   Staging Area --&gt;&gt;  Working Tree: git reset (--mixed)
</code></pre>
<p>Die ersten Schritte vom Working Tree zum Commit Tree kennen wir ja schon. Aber was passiert, wenn wir einen Fehler gemacht haben und die Datei wieder aus der Staging Area entfernen wollen? Oder wir auf unseren letzten Commit zur√ºck wollen? Das und viels mehr schauen wir uns auf der n√§chsten Seite an.</p>
<blockquote>
<p>Was machen wir mit Datein, die wir niemals Tracken wollen. Zum Beispiel weil sie sensible Informationen enthalten oder viel zu gro√ü sind? Daf√ºr gibt es die <code>.gitignore</code> Datei. In dieser Datei k√∂nnen wir Datein oder Ordner angeben, die git vollst√§ndig ignorieren soll. Einfach die Datei im top-level Ordner des Repositories erstellen und die Datein oder Ordner angeben, die ignoriert werden sollen. Mehr dazu in der <a href="https://git-scm.com/docs/gitignore">Dokumentation</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkout-und-reset"><a class="header" href="#checkout-und-reset">Checkout und Reset</a></h1>
<p><a href="git/./erstes_repository.html#repository-clonen">Vorhin</a> haben wir bereits gesehen wie wir <code>git clone</code> funktioniert und wie wir unser im Workshop erstelltes Beispiel clonen k√∂nnen. In diesem Kapitel sehen wir wie die Version History von Git in der Praxis funktioniert, wie wir uns in der History bewegen k√∂nnen und wie wir √Ñnderungen r√ºckg√§ngig machen k√∂nnen. Aber bevor wir irgendwelche √Ñnderungen an unserem Repository vornehme, sollten wir uns erstmal einen √úberblick √ºber das Repository verschaffen.</p>
<h1 id="den-√úberblick-behalten"><a class="header" href="#den-√úberblick-behalten">Den √úberblick behalten</a></h1>
<p>Vorhin haben wir einfach den Status mit <code>git status</code> abgefragt und waren gl√ºcklich damit. Schlie√ülich gab es ja noch keine Commits in unserem Repository. Was aber wenn wir aber schon welche haben? Hier kommt <code>git log</code> ins Spiel.</p>
<p>Wechseln wir in unser geclontes Repository und schauen uns die Version History von Git an:</p>
<pre><code class="language-bash">$ cd my_git_repo
$ git log
&gt; commit ade5234ac06311dff9f6cf5fc988bcc056533e57 (HEAD -&gt; main)
  Author: Leon Fuss &lt;leon.fuss@icloud.com&gt;
  Date:   Tue Apr 16 15:58:23 2024 +0200

      added call to hello_user

  commit e0a79308cb8dd4937585c70ed462fc9a40977e55
  Merge: f239baa 656d544
  Author: Leon Fuss &lt;leon.fuss@icloud.com&gt;
  Date:   Tue Apr 16 15:08:28 2024 +0200

      Merge branch 'feature/hello_user'
 ...
</code></pre>
<p>Hier sehen wir die letzten Commits. Jeder commit beginnt mit dem Keyword <code>commit</code> gefolgt von seinem Commit Hash. Danach folgt das Autor, das Datum und die Commit Message. Am Obersten Commit wird immer HEAD gesetzt sein und zeigt an wie und worauf er gesetzt ist. In unserem Fall ist HEAD auf den Branch <code>main</code> gesetzt - erkennbar an <code>(HEAD -&gt; main)</code>.</p>
<p>Meist gibt dieser √úberblick schon genug Informationen um sich zumindest zu erinnern an was man als letztes gearbeitet hat. F√ºr einen besseren √úberblick gibt es aber bessere Optionen:</p>
<pre><code class="language-bash">  $ git log --oneline --graph --all
  &gt; * 90aeab1 (feature/loop) adapted for repeated echo calls
  | * ade5234 (HEAD -&gt; main) added call to hello_user
  |/
  *   e0a7930 Merge branch 'feature/hello_user'
  |\
  | * 656d544 (feature/hello_user) added hello_user
  * | f239baa added echo functionality
  |/
  * 13db86d added ussage description to README
  * 38333e6 init rust repo
  * 85cbf15 Initial commit
</code></pre>
<p>Hier haben wir viele Optionen auf einmal verwendet. Was bewirken wir damit?</p>
<ul>
<li><code>--oneline</code> zeigt die Commits in einer Zeile an. Auch der Hash wird auf die minimale eindeutige L√§nge gek√ºrzt</li>
<li><code>--graph</code> zeigt die Commits in einer Grahen Darstellung. Damit k√∂nnen wir die Branch struktur erkennen</li>
<li><code>--all</code> zeigt alle Branches an. Ohne diese sehen wir nur die Commits die vor unserem aktuellen HEAD liegen</li>
</ul>
<p>Die Optionen kannst du Kombineren wie du willst. Ich pers√∂nlich pr√§ferenziere die Graphen Darstellung und die einzeilige Anzeige. Das gibt mir einen guten √úberblick √ºber die Branch Struktur und die Commit Historie.</p>
<p>Damit wir auch wirlich verstehen was hier steht k√∂nnen stellen wir das ganze hier einmal in unseren bereit bekannten Graphen dar. Unser Head liegt aktuell auf dem letzten Commit von <code>main</code> (umrandet):</p>
<pre><code class="language-mermaid">---
title:  Commit Graph
---
gitGraph
   commit id: &quot;Initial commit&quot;
   commit id: &quot;init rust repo&quot;
   commit id: &quot;added ussage description to README&quot;
   branch feature/hello_user
   checkout main
   commit id: &quot;added echo functionality&quot;
   checkout feature/hello_user
   commit id: &quot;added hello_user&quot;
   checkout main
   merge feature/hello_user
   branch feature/loop
   checkout main
   commit id: &quot;added call to hello_user&quot; type: HIGHLIGHT
   checkout feature/loop
   commit id: &quot;adapted for repeated echo calls&quot;
   checkout main
</code></pre>
<p>Hier haben wir der Klarheit halber die Commit Messages als Commit ID verwendet. Das sollte dir helfen zu verstehen wie die Commits in der Historie zueinander stehen. Normalerweise w√ºrden wir hier die Commit Hashes verwenden.</p>
<blockquote>
<p>Wollen wir nur die Commits eines bestimmten Files sehen, k√∂nnen wir das mit <code>git log &lt;file_name&gt;</code> tun.</p>
</blockquote>
<h1 id="checkout"><a class="header" href="#checkout">Checkout</a></h1>
<p>Jetzt wo wir unsere Karte haben, k√∂nnen wir uns im Commit Graph bewegen. Aber was meint das eigentlich?</p>
<blockquote>
<p>Im folgenden setzten wir ein cleanes Repository voraus. Das hei√üt, dass der Working Tree mit dem letzten Commit √ºbereinstimmt und die Staging Area leer ist. <code>git log</code> sollte dann so auschauen:</p>
<pre><code class="language-bash">$ git log
&gt; On branch main
  nothing to commit, working tree clean
</code></pre>
<p>Was wir machen k√∂nnen, wenn das nicht der Fall ist siehst du <a href="git/./checkout_und_reset.html#stashing">hier</a></p>
</blockquote>
<p>Hast du noch unser Diagramm zu Working und Commit Tree sowie der Stashing Area im Kopf?:</p>
<pre><code class="language-mermaid">sequenceDiagram
   Working Tree -&gt;&gt; Staging Area: git add &lt;file&gt;
   Staging Area -&gt;&gt; Commit Tree: git commit
   Commit Tree --&gt;&gt; Working Tree: git checkout
</code></pre>
<p>Hier gab es schon einen kleinen Hinweis darauf was passiert, wenn wir um Commit Tree herumwandern. Jedes Mal wenn wir uns einen vergangen Commit ansehen, wird der Inhalt des Working Tree auf den Stand des ausgew√§hlten Commits gebracht. In der git Welt nennen wir das <code>checkout</code>.
Diese √úberschreibung unseres Working Trees ist auch der Grund warum wir immer darauf achten sollten, dass unser Working Tree sauber ist bevor wir uns in der Historie bewegen. Sollten wir ungespeicherte (nicht commited) √Ñnderungen haben, werden diese √ºberschrieben. Aber keine Sorge: git l√§sst uns nicht einfach in den Abgrund laufen. Sollten wir ungespeicherte √Ñnderungen haben, wird uns einen wechsel verweigern bis wir einen cleanen Working Tree haben.</p>
<blockquote>
<p>Commit oder doch Branch? Der Unterschied wird jetzt wichtig f√ºr uns. Falls du nicht mehr ganz sicher bist, lies nochmal <a href="git/./datenmodell_git.html#besonderheiten-von-branches">hier</a></p>
</blockquote>
<p>Bei einem Checkout passieren zwei Dinge:</p>
<ol>
<li>Der HEAD wird auf den ausgew√§hlten Branch/Commit/Tag gesetzt</li>
<li>Der Working Tree wird auf den Stand des ausgew√§hlten Branch/Commit/Tag gebracht</li>
</ol>
<p>Erinnerst du dich wie Braches immer auf den aktuellsten Branch ihres Zweiges zeigen? Wenn wir auf dem Branch Commiten wir auch der Branch Pointer auf den letzen Commit verschoben. √Ñhnlich zum Branch ist auch der HEAD nur ein Pointer. Setzen wir den Pointer auf einen Branch und der Branch bewegt sich, wird auch der HEAD auf den neuen Commit gesetzt. Wenn hingegen der HEAD direkt auf einen Commit zeigt, bleibt er dort stehen.</p>
<p>Lass uns erstmal den HEAD auf einen Branch setzten. Das ist der weitaus h√§ufigere Anwendungsfall:</p>
<pre><code class="language-mermaid">---
title:  Commit Graph - HEAD auf main
---
gitGraph
   commit id: &quot;85cbf1&quot;
   commit id: &quot;38333e&quot;
   branch feature/1
   commit id: &quot;90aeab&quot;
   commit id: &quot;25fe3a&quot;
   checkout main
   commit id: &quot;656d54&quot;
   commit id: &quot;de5234&quot; type: HIGHLIGHT
</code></pre>
<pre><code class="language-bash">$ git checkout feature/1
</code></pre>
<pre><code class="language-mermaid">---
title:  Commit Graph - HEAD auf feature/1
---
gitGraph
  commit id: &quot;85cbf1&quot;
  commit id: &quot;38333e&quot;
  branch feature/1
  commit id: &quot;90aeab&quot;
  commit id: &quot;25fe3a&quot; type: HIGHLIGHT
  checkout main
  commit id: &quot;656d54&quot;
  commit id: &quot;de5234&quot;
</code></pre>
<p>Passend zu unserem HEAD wir auch immer das Working Directory auf den Stand des HEADs gebracht. Das bedeutet, dass wir jetzt die Dateien aus dem Commit <code>feature/1</code> im Working Directory haben.</p>
<p>Was passiert wenn wir den HEAD direkt auf einen Commit setzten?</p>
<p>Bewegen wir uns doch auf einen Commit:</p>
<pre><code class="language-bash">  $ git checkout 656d54
  &gt; Note: switching to '656d54'.

    You are in 'detached HEAD' state. You can look around, make experimental
    changes and commit them, and you can discard any commits you make in this
    state without impacting any branches by switching back to a branch.


    HEAD is now at 656d54
</code></pre>
<pre><code class="language-mermaid">---
title:  Commit Graph - HEAD auf feature/1
---
gitGraph
  commit id: &quot;85cbf1&quot;
  commit id: &quot;38333e&quot;
  branch feature/1
  commit id: &quot;90aeab&quot;
  commit id: &quot;25fe3a&quot;
  checkout main
  commit id: &quot;656d54&quot; type: HIGHLIGHT
  commit id: &quot;de5234&quot;
</code></pre>
<p>An sich kein Problem. Der HEAD zeigt jetzt auf den Commit <code>656d54</code> und unser Working Tree ist auf dem passenden Stand gebracht. Aber warum werden wir darauf hingeweisen dass wir jetzt in einem &quot;detached HEAD&quot; Zustand sind? Und was ist das √ºberhaupt?</p>
<p>Braches zeigen immer auf den letzten Commit ihres Zweiges. Und Branches sind die einzigen Orte an denen wir neue (erreichbare) Commits erstellen k√∂nnen. &quot;detached HEAD&quot; beschreibt also den Zustand indem wir nicht mehr direkt auf einen Branch verweisen und somit auch keinen neuen Commit erstellen sollten.</p>
<blockquote>
<p>‚ÄºÔ∏è Achtung: Commits sind nur √ºber Branches erreichbar. Im &quot;detached HEAD&quot; k√∂nnen wir zwar Commits erstellen, aber sie sind nicht erreichbar. Um sie dauerhaft erreichen zu k√∂nnen m√ºssen wir sie einen neuen Branch erstellen (<code>git branch &lt;branch_name&gt;</code>). Solltet ihr das vergessen wird euch git beim n√§chsten Checkout auf einen Branch darauf hinweisen. Falls ihr das vergesst ist es Zeit die Seite <a href="git/./help.html">Help! I fucked up</a> zu lesen.</p>
</blockquote>
<blockquote>
<p>Solltet ihr noch einen √§ltere Version von git haben, ist der Hinweis noch deutlich dramatischer und warnt deutlich agressiver, dass Commits verloren gehen k√∂nnen. &quot;detached HEAD&quot; ist aber ein normaler Zustand und kein Grund zur Panik. Wenn ihr ihn wieder verlassen wollt, k√∂nnt ihr einfach auf einen Branch wechseln. Zum Beispiel mit <code>git checkout main</code>.</p>
</blockquote>
<h3 id="relative-commits"><a class="header" href="#relative-commits">Relative Commits</a></h3>
<p>Navigation mit Commit Hashes ist nicht immer das angenehmste. Warum sollte man eine komische Buchstaben und Zahlenkombination erst im Log raussuchen und dann eingeben um einfach einen Commit zur√ºck zu gehen. Hier kommen Relative Pfade ins Spiel.</p>
<p>Mit <code>&lt;branch/commit&gt;~</code> bzw. <code>&lt;branch/commit&gt;~n</code> kannst du einen bzw <code>n</code>-Schritte dem Commit Graphen folgen.</p>
<p>Schauen wir uns ein Beispiel an.</p>
<pre><code class="language-mermaid">---
title:  Commit Graph - HEAD auf main
---
gitGraph
  commit id: &quot;85cbf1&quot;
  commit id: &quot;38333e&quot;
  branch feature/1
  commit id: &quot;90aeab&quot;
  commit id: &quot;25fe3a&quot;
  checkout main
  commit id: &quot;656d54&quot;
  commit id: &quot;de5234&quot;
  merge feature/1
  commit id: &quot;a1b2c3&quot; type: HIGHLIGHT
</code></pre>
<pre><code class="language-bash">$ git checkout main~3
</code></pre>
<pre><code class="language-mermaid">---
title:  Commit Graph - HEAD auf 656d54
---
gitGraph
  commit id: &quot;85cbf1&quot;
  commit id: &quot;38333e&quot;
  branch feature/1
  commit id: &quot;90aeab&quot;
  commit id: &quot;25fe3a&quot;
  checkout main
  commit id: &quot;656d54&quot; type: HIGHLIGHT
  commit id: &quot;de5234&quot;
  merge feature/1
  commit id: &quot;a1b2c3&quot;
</code></pre>
<p>Aber wie kommen wir bei einem Merge Commit auf den richtigen Commit? Schlie√ülich f√ºhrt ein Merge Commit auf zwei verschiedene Commits zur√ºck. Unser bereits bekannter <code>~</code>-Operator w√§hlt hier immer den Hauptstrang - auf den gemergt wurde - aus. Wenn wir den anderen Zweit ausw√§hlen wollen, k√∂nnen wir den <code>^</code>-Operator verwenden.</p>
<pre><code class="language-mermaid">---
title:  Commit Graph - HEAD auf main
---
gitGraph
  commit id: &quot;85cbf1&quot;
  commit id: &quot;38333e&quot;
  branch feature/1
  commit id: &quot;90aeab&quot;
  commit id: &quot;25fe3a&quot;
  checkout main
  commit id: &quot;656d54&quot;
  commit id: &quot;de5234&quot;
  merge feature/1
  commit id: &quot;a1b2c3&quot; type: HIGHLIGHT
</code></pre>
<pre><code class="language-bash">$ git checkout main~1^~
</code></pre>
<blockquote>
<p><code>~</code> folgt dem Hauptstrang, <code>^</code> folgt dem Nebenstrang Strang. Aber <code>^n</code> folgt nicht solange dem Hauptstrang bis es einen Nebenstrang gibt, sondern versucht den <code>n</code>-ten Elternknoten zu finden. Das spielt erst eine Rolle wenn ein merge mehr als zwei Eltern hat.</p>
</blockquote>
<pre><code class="language-mermaid">---
title:  Commit Graph - HEAD auf main
---
gitGraph
  commit id: &quot;85cbf1&quot;
  commit id: &quot;38333e&quot;
  branch feature/1
  commit id: &quot;90aeab&quot; type: HIGHLIGHT
  commit id: &quot;25fe3a&quot;
  checkout main
  commit id: &quot;656d54&quot;
  commit id: &quot;de5234&quot;
  merge feature/1
  commit id: &quot;a1b2c3&quot;
</code></pre>
<h1 id="reset"><a class="header" href="#reset">Reset</a></h1>
<p>Du hast √Ñnderungen commited die du nicht commiten wolltest? Der Staging Area zu viel hinzugef√ºgt? Euer Softwareprojekt l√§uft seit deinen letzten √Ñnderungen gar nicht mehr? Dann bist du hier richtig. Alles was du gemacht hast l√§sst sich auch wieder R√ºckg√§ngig machen.</p>
<p>Reset gibt es in verschiedenen Formen:</p>
<ul>
<li>soft</li>
<li>mixed</li>
<li>hard</li>
</ul>
<p>√Ñhnlich zu Checkout ver√§ndert Reset den Working Tree sowie die Staging Area. Aber im Gegensatz zu Checkout scheint Reset nur den HEAD zu ver√§ndern. In Wirklichkeit verschiebt Reset nur den zugrundeliegenden Branch und damit indirekt auch den HEAD. Dieser Unterschied ist wichtig. W√§hrend wir einen Checkout durch einen anderen Checkout sehr einfach r√ºckg√§ngig machen k√∂nnen, ist das beim Reset komplizierter, da wir keine Branch mehr haben die auf die alten Commits zeigt. Sollte dir das aus Versehen passieren, lies dir die Seite <a href="git/./help.html">Help! I fucked up</a> durch.</p>
<h3 id="soft-reset"><a class="header" href="#soft-reset">Soft Reset</a></h3>
<p>Ein Soft Reset ver√§ndert nur den Branch Pointer und hat ansonsten keine Auswirkungen. Somit setzt es nur den letzten Commit Befehl zur√ºck. Die Staging Area enth√§lt alles was in dem Commit enthalten war. Wir schauen uns das ganze an einem Beispiel an.</p>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;v1&quot;
commit id: &quot;v2&quot;
commit id: &quot;v3&quot; type: HIGHLIGHT
</code></pre>
<pre><code class="language-mermaid">stateDiagram-v2
    HEAD --&gt; v3
    Staging --&gt; v3
    Working --&gt; v3
</code></pre>
<pre><code class="language-bash">$ git reset --soft HEAD~
</code></pre>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;v1&quot;
commit id: &quot;v2&quot; type: HIGHLIGHT
commit id: &quot;v3&quot; type: REVERSE
</code></pre>
<pre><code class="language-mermaid">stateDiagram-v2
    HEAD --&gt; v2
    Staging --&gt; v3
    Working --&gt; v3
</code></pre>
<blockquote>
<p>Alle git Befehle k√∂nnen auch immer mit relativen Commit Referenzen (<code>~</code> und <code>^</code>) aufgerufen werden. Grade bei Reset bietet sich das an, weil man meist nur wenige Commits zur√ºck will. Zum Beispiel <code>git reset --soft HEAD~</code></p>
</blockquote>
<h3 id="mixed-reset"><a class="header" href="#mixed-reset">Mixed Reset</a></h3>
<p>Bei einem Mixed Reset wird wie zurvor auch beim Soft Reset zun√§chst der HEAD auf den angegebenen Commit zur√ºckgesetzt. Danach wird der neue HEAD in die Staging Area geladen. Somit wird der letzte Commit r√ºckg√§ngig gemacht und auch die Staging Area wird geleert. Alle √Ñnderungen im Working Tree bleiben erhalten.</p>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;v1&quot;
commit id: &quot;v2&quot;
commit id: &quot;v3&quot; type: HIGHLIGHT
</code></pre>
<pre><code class="language-mermaid">stateDiagram-v2
    HEAD --&gt; v3
    Staging --&gt; v3
    Working --&gt; v3
</code></pre>
<pre><code class="language-bash">$ git reset --mixed HEAD~
# oder
$ git reset HEAD~
</code></pre>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;v1&quot;
commit id: &quot;v2&quot; type: HIGHLIGHT
commit id: &quot;v3&quot; type: REVERSE
</code></pre>
<pre><code class="language-mermaid">stateDiagram-v2
    HEAD --&gt; v2
    Staging --&gt; v2
    Working --&gt; v3
</code></pre>
<h3 id="hard-reset"><a class="header" href="#hard-reset">Hard Reset</a></h3>
<p>Ein Hard Reset ist die weitgehendste Form des Resets. Hier wird der HEAD auf den angegebenen Commit gesetzt und die Staging Area, sowie der Working Tree mit diesem Commit √ºberschrieben.</p>
<blockquote>
<p>Achtung: Uncommitede √Ñnderungen im Workiung Directory gehen vollst√§ndig verloren. Dies ist der einzige Befehl mit dem git Dateien unwiederbringlich l√∂scht. Bitte gehe mit Option <code>--hard</code> vorsichtig um.</p>
</blockquote>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;v1&quot;
commit id: &quot;v2&quot;
commit id: &quot;v3&quot; type: HIGHLIGHT
</code></pre>
<pre><code class="language-mermaid">stateDiagram-v2
    HEAD --&gt; v3
    Staging --&gt; v3
    Working --&gt; v3
</code></pre>
<pre><code class="language-bash">$ git reset --hard HEAD~
</code></pre>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;v1&quot;
commit id: &quot;v2&quot; type: HIGHLIGHT
commit id: &quot;v3&quot; type: REVERSE
</code></pre>
<pre><code class="language-mermaid">stateDiagram-v2
    HEAD --&gt; v2
    Staging --&gt; v2
    Working --&gt; v2
</code></pre>
<p>In keinem der F√§lle wird ein Commit direkt gel√∂scht. Wie du einen reseteten Commit wiederherstellen kannst, erf√§hrst du <a href="git/./help.html">hier</a>.</p>
<h2 id="reset-mit-dateipfad"><a class="header" href="#reset-mit-dateipfad">Reset mit Dateipfad</a></h2>
<p>Reset kann zus√§tzlich zu dem Commit auch mit einem Dateipfad aufgerufen werden. Der Syntax daf√ºr schaut wie folgt aus:</p>
<pre><code class="language-bash">$ git reset &lt;commit&gt; &lt;file&gt;
</code></pre>
<p>Aber was passiert hier eigentlich? HEAD bzw. der Branch der zugrundeliegt sind Pointer und k√∂nnen somit immer nur auf einen Commit zeigen. Sie k√∂nnen also nicht mehrere Commits f√ºr unterschiedliche Datein referenzieren. Dementsprechend wird bei einem Reset mit Dateipfad die Branch nicht ver√§ndert. Die Staging Area und der Working Tree hingegen k√∂nnen ganz unterschiedliche Datein enthalten. Der Reset Befehl setzt also nur die angegebene Datei auf den spezifizierten Commit zur√ºck. Ob auch der Working Tree vom Reset betroffen ist, h√§ngt von der gew√§hlten Reset Art ab.</p>
<blockquote>
<p><code>git reset HEAD &lt;file&gt;</code> nimmt die Datei aus der Staging Area bzw. √ºberschreibt die Datei in der Staging Area mit der Datei aus dem letzten Commit. Der Working Tree bleibt unver√§ndert.
Wer es noch k√ºrzer mag, kann auch das HEAD weglassen. <code>git reset &lt;file&gt;</code> hat den gleichen Effekt.</p>
</blockquote>
<p>In unserem Beispiel setzten mir die Datei <code>file.txt</code> auf den Stand des letzten Commits zur√ºck.</p>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;v1&quot;
commit id: &quot;v2&quot;
commit id: &quot;v3&quot; type: HIGHLIGHT
</code></pre>
<pre><code class="language-mermaid">stateDiagram-v2
    HEAD --&gt; v3
    Staging --&gt; v3
    Working --&gt; v3
</code></pre>
<pre><code class="language-bash">$ git reset HEAD~ foo.txt
</code></pre>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;v1&quot;
commit id: &quot;v2&quot; type: HIGHLIGHT
commit id: &quot;v3&quot; type: REVERSE
</code></pre>
<pre><code class="language-mermaid">stateDiagram-v2

    x: v3
    y: v3
    z: v2 - foo.txt \n v3 - rest

    HEAD --&gt; y
    Staging --&gt; z
    Working --&gt; x
</code></pre>
<blockquote>
<p>Soft Reset macht mit Dateinamen keinen Sinn, da der Pointer auf den Branch bleibt.</p>
</blockquote>
<h1 id="squashing"><a class="header" href="#squashing">Squashing</a></h1>
<p>Oftmals schreibt man auf einer Branch mehrere Commits die man vor einem Merge der √úbersicht halber lieber zusammenfassen m√∂chte. Das Zusammenfassen mehrerer Commits in einen Commit nennt man Squashing. Meistens f√ºhrt man Squashing mittels eines interakiven Rebase durch. Wie das funktioniert schauen wir uns auch sp√§ter an. Aber f√ºr denn Fall, dass wir die letzten Commits zusammenfassen wollen, k√∂nnen wir auch einen einfachen Reset verwenden.</p>
<p>Wir gehen wie folgt vor:</p>
<ol>
<li>Soft Reset auf den Commit vor den Commits die wir zusammenfassen wollen</li>
<li>Neuer Commit erstellen</li>
</ol>
<p>In unserem Beispiel wollen wir die letzten beiden Commits zusammenfassen.</p>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;v1&quot;
commit id: &quot;v2&quot;
commit id: &quot;v3&quot; type: HIGHLIGHT
</code></pre>
<pre><code class="language-mermaid">stateDiagram-v2
    HEAD --&gt; v3
    Staging --&gt; v3
    Working --&gt; v3
</code></pre>
<pre><code class="language-bash">$ git reset --soft HEAD~2
</code></pre>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;v1&quot; type: HIGHLIGHT
commit id: &quot;v2&quot; type: REVERSE
commit id: &quot;v3&quot; type: REVERSE
</code></pre>
<pre><code class="language-mermaid">stateDiagram-v2
    HEAD --&gt; v1
    Staging --&gt; v3
    Working --&gt; v3
</code></pre>
<p>In der Staging Area und im Working Tree befinden sich nun die √Ñnderungen aller Commits die wir zusammenfassen wollen. Jetzt m√ºssen wir nur noch einen neuen Commit erstellen.</p>
<pre><code class="language-bash">$ git commit -m &quot;Squashed commit&quot;
</code></pre>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;v1&quot;
commit id: &quot;v4&quot; type: HIGHLIGHT
</code></pre>
<p>Wir haben erfolgreich die letzten beiden Commits in einen Commit zusammengefasst.</p>
<h1 id="stashing"><a class="header" href="#stashing">Stashing</a></h1>
<ul>
<li>Checkout funktioniert nur wenn die Staging Area und der Working Tree auf dem Stand vom letzten Commit sind</li>
<li>Manchmal nehmen wir √§nderungen vor die noch nicht commit-bereit sind, m√ºssen aber an was anderem arbeiten / branch wechseln</li>
<li>Stashing speichert die √Ñnderungen in einem tempor√§ren Commit der unabh√§ngig vom Commit Tree ist und setzt Working Directory und Staging Area zur√ºck</li>
</ul>
<p>Beispiel:</p>
<pre><code class="language-bash">$ git status
&gt; Changes to be committed:
    (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	  modified:   bar.txt

  Changes not staged for commit:
    (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
    (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	  modified:   src/foo.txt
</code></pre>
<p>Wir wollen jetzt Branch wechseln, aber die √Ñnderungen in <code>src/foo.txt</code> sind noch nicht commit-bereit. Mit <code>git-stash</code> k√∂nnen wir die √Ñnderungen tempor√§r speichern.</p>
<pre><code class="language-bash">$ git stash
&gt; Saved working directory and index state \
   &quot;WIP on master: 049d078 Create index file&quot;
  HEAD is now at 049d078 Create index file
  (To restore them type &quot;git stash apply&quot;)
</code></pre>
<p>Working Tree und Staging Area sind jetzt wieder auf dem Stand vom letzten Commit und damit bereit den Branch zu wechseln. Wir k√∂nnen das mit <code>git status</code> √ºberpr√ºfen.</p>
<pre><code class="language-bash">$ git status
&gt; On branch main
  nothing to commit, working directory clean
</code></pre>
<p>Wir k√∂nnen jetzt nach belieben Branch wechseln und wo anders weiterarbeiten.</p>
<p>Um unsere akutellen Stashes anzuzeigen k√∂nnnen wir <code>git stash list</code> verwenden.</p>
<pre><code class="language-bash">$ git stash list
&gt; stash@{0}: WIP on master: 049d078 Create index file
&gt; stash@{1}: WIP on master: 3923d03 Revert add file size
</code></pre>
<p>Hier sehen wir das wir zwei Stashes haben. Den oberen haben wir grade erstellt. Um die Stashes unterscheiden zu k√∂nnen f√ºgt git immer die Commit Message des letzten Commits hinzu. Wahlweise kann sie auch bei der Erstellung mit der Option <code>-m</code> angegeben werden (z.B. <code>git stash -m &quot;Meine Nachricht&quot;</code>).
Um einen Stash kann auf einer beliebigen Branch wiederhergestellt werden, jedoch kann es bei der Anwendung zu Konfliken kommen. Wie diese gel√∂st werden schauen wir uns im Kapitel <a href="git/./git/branching_und_merging.html">Branching und Merging</a> an.</p>
<p>Um unseren Stash auf den aktuellen Working Tree und Staging Area anzuwenden verwenden wir <code>git stash apply</code>. Sollten wir nicht den letzten Stash anwenden wollen m√ºssen wir die ID mit <code>git stash apply stash@{1}</code> angeben.</p>
<pre><code class="language-bash">$ git stash apply stash@{0}
&gt; On branch master
  Changes not staged for commit:
    (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
    (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	  modified:   bar.txt
	  modified:   src/foo.txt

  no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>Wenn wir den Stash nicht mehr ben√∂tigen k√∂nnen wir ihn mit <code>git stash drop stash@{0}</code> l√∂schen. F√ºr alle Stashes funktioniert das mit <code>git stash clear</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="help-i-fucked-up"><a class="header" href="#help-i-fucked-up">Help! I fucked up</a></h1>
<p>Git kann praktisch alle Operationen r√ºckg√§ngig machen. Eine der wenigen Ausnahme haben wir im letzten Kapitel gesehen: Wenn ein Hard Reset durchgef√ºhrt wird, ohne dass √Ñnderungen commited wurden, gehen diese unwiederbringlich verloren.</p>
<h1 id="reflog"><a class="header" href="#reflog">Reflog</a></h1>
<p>Abgesehen davon speichert git alle √Ñnderungen von Commits und Branches im Repository die wir vorgenommen haben. Wir k√∂nnen all diese im Reflog anschauen:</p>
<pre><code class="language-bash">$ git reflog
&gt; e0a7930 HEAD@{0}: merge feature/hello_user: Merge made by the 'ort' strategy.
  f239baa HEAD@{1}: checkout: moving from feature/hello_user to main
  656d544 (feature/hello_user) HEAD@{2}: commit: added hello_user
  f239baa HEAD@{3}: commit: added echo functionality
</code></pre>
<h2 id="back-in-time"><a class="header" href="#back-in-time">Back in Time</a></h2>
<p>Um in der Zeit zur√ºckzugehen bevor wir etwas versehentlich kaputt gemacht haben, m√ºssen wir nur einen reset in Kombination mit unserer <code>HEAD@{index}</code> Referenz durchf√ºhren. Git setzt daraufhin alle √Ñnderungen bis zu diesem Zeitpunkt zur√ºck.</p>
<pre><code class="language-bash">$ git reset HEAD@{index}
</code></pre>
<p>Oben haben wir gesehen, dass wir als letztes einen Merge durchgef√ºhrt hatten. Sollten wir diesen r√ºckg√§ngig machen wollen, k√∂nnen wir das mit folgendem Befehlt tun:</p>
<pre><code class="language-bash">$ git reset HEAD@{1}
</code></pre>
<p>Schauen wir uns daraufhin das Reflog erneut an:</p>
<pre><code class="language-bash">$ git reflog
&gt; 1533063 (HEAD -&gt;  main) HEAD@{0}: reset: moving to HEAD@{1}
  e0a7930 HEAD@{1}: merge feature/hello_user: Merge made by the 'ort' strategy.
  f239baa HEAD@{2}: checkout: moving from feature/hello_user to main
  656d544 (feature/hello_user) HEAD@{3}: commit: added hello_user
  f239baa HEAD@{4}: commit: added echo functionality
</code></pre>
<p>Auch unser Reset wurde im Reflog festgehalten. Wir k√∂nnen also auch diesen also jederzeit wieder r√ºckg√§ngig machen.</p>
<blockquote>
<p>Auch wenn wir all diese √Ñnderungen mit dem bereits bekannten <code>git reset</code> durchf√ºhren k√∂nnen, ist es oft deutlich einfacher und sicherer, wenn wir die Reflog Referenzen als Adressierung verwenden. Grade bei Resets von Merges k√∂nnen wir sonst schnell auf die falsche Referenz zur√ºcksetzten. Reflog in Kombination mit <code>git reset</code> ist also so etwas wie unsere Time Machine.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="branching-und-merging"><a class="header" href="#branching-und-merging">Branching und Merging</a></h1>
<h1 id="branching"><a class="header" href="#branching">Branching</a></h1>
<p>Wir haben bereits viele Commit Trees gesehen und meistens waren diese nicht nur linear, sondern hatten bereits mehrere Branches. Was Branches sind haben wir bereits gesehen, aber wie k√∂nnen wir diese erstellen.</p>
<p>Wir begeben uns in unserem Repository mittel <code>checkout</code> an den Commit, von dem wir aus einen neuen Branch erstellen wollen. Das kann ein Branch wie <code>main</code> sein oder auch ein Commit, der schon l√§nger zur√ºckliegt. Dort angekommen erstellen wir einen neuen Branch mit dem Befehl <code>git branch &lt;branch_name&gt;</code>.
Wollen wir also den Branch <code>feature/1</code> von <code>main</code> erstellen, machen wir folgendes:</p>
<pre><code class="language-bash">$ git checkout main
$ git branch feature/1
</code></pre>
<p>Bevor wir nun Commits unserm neunen Branch hinzuf√ºgen k√∂nnen, m√ºssen wir noch auf unseren neu erstellten Branch wechseln:</p>
<pre><code class="language-bash">$ git checkout feature/1
</code></pre>
<p>Wahlweise k√∂nnen wir auch das Erstellen und Wechseln in einem Befehl durchf√ºhren:</p>
<pre><code class="language-bash">$ git checkout -b feature/1
</code></pre>
<blockquote>
<p>Die <code>-b</code> Flag steht hierbei f√ºr <code>branch</code>.</p>
</blockquote>
<p>In git gilt der Grundsatz: &quot;Branch early, branch often&quot;. Das hei√üt du wirst in der Regel mit vielen Branches konfrontiert sein. Diese alle √ºber das Log zu verfolgen ist nicht immer sinnvoll. Solltest du einfach nur wissen wollen, welche Branches es gibt, kannst du das mit dem Befehl <code>git branch</code> tun.</p>
<pre><code class="language-bash">$ git branch
&gt; * feature/1
  main
</code></pre>
<p>Der aktuelle Branch (HEAD) ist mit einem <code>*</code> markiert.</p>
<p>Nach einem <a href="git/./branching_und_merging.html#Merging">Merge</a> oder <a href="git/./rebase_und_cherry_picking.html#Rebasing">Rebase</a>, wenn alle √Ñnderungen auf einem anderen Branch √ºbernommen worden sind, k√∂nnen wir den alten Branch l√∂schen. Das machen wir mit dem Befehl <code>git branch -d &lt;branch_name&gt;</code>.</p>
<p>Sollten wir also <code>feature/1</code> wieder l√∂schen wollen, schaut das wie folgt aus:</p>
<pre><code class="language-bash">    $ git branch -d feature/1
</code></pre>
<blockquote>
<p>Wie das L√∂schen wieder R√ºckg√§ngig gemacht werden kann findest du <a href="git/./help.html">hier</a></p>
</blockquote>
<h1 id="merging"><a class="header" href="#merging">Merging</a></h1>
<p>Merging hatten wir bereits ganz am Anfang in Kombination mit dem Datenmodell angesprochen. Beim Merging wollen wir die √Ñnderungen aus zwei unterscheidlichen Branches zusammenf√ºhren. Dabei wird die √Ñnderungen des einen Branches mit einem Merge-Commit auf den anderen √ºbernommen. Der Merge-Commit hat zwei oder mehrere Parent-Commits ist ansonsten aber identisch zu einem normalen Commit.</p>
<blockquote>
<p>Wichtig: Nur der Pointer des Zielbranches wird auf den Merge-Commit verschoben. Der Pointer vom Quellbranch bleibt unver√§ndert.</p>
</blockquote>
<p>In git mergen wir mit dem Befehl <code>git merge &lt;quell_branch&gt;</code> der Zielbranch ist dabei immer der Branch auf dem sich grade HEAD befindet.</p>
<p>Schauen wir uns das denkbar einfachste Beispiel an:</p>
<pre><code class="language-mermaid">gitGraph

  commit id: &quot;ae3f3d&quot; type: HIGHLIGHT
  branch feature/1
  commit id: &quot;9ac33d&quot;
  checkout main
</code></pre>
<pre><code class="language-bash">$ git merge feature/1
</code></pre>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;ae3f3d&quot;
branch feature/1
commit id: &quot;9ac33d&quot;
checkout main
merge feature/1 type: HIGHLIGHT id: &quot;b3f3d3&quot;
</code></pre>
<p>Alle √Ñnderungen von <code>feature/1</code> wurden auf <code>main</code> √ºbernommen. Auf <code>feature/1</code> hat sich nichts ver√§ndert. Es befinden sich dort nur die Commits, die es auch schon vorher gab.</p>
<h2 id="fast-forward-merges"><a class="header" href="#fast-forward-merges">Fast-Forward Merges</a></h2>
<p>Sollten wir jetzt auf <code>main</code> ein paar Commits hinzuf√ºgen und dann <code>main</code> in <code>feature/1</code> mergen (andersherum als vorhin), wird interessanter Weise kein neuer Merge-Commit erstellt.</p>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;ae3f3d&quot;
branch feature/1
commit id: &quot;9ac33d&quot;
checkout main
merge feature/1  id: &quot;b3f3d3&quot;
commit id: &quot;3f3f3f&quot;
commit id: &quot;52acd8&quot; type: HIGHLIGHT
</code></pre>
<pre><code class="language-bash">$ git checkout feature/1
$ git merge main
</code></pre>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;ae3f3d&quot;
branch feature/1
commit id: &quot;9ac33d&quot;
checkout main
merge feature/1
commit id: &quot;3f3f3f&quot;
commit id: &quot;52acd8&quot;
checkout feature/1
merge main type: HIGHLIGHT
</code></pre>
<p>Unser aktueller HEAD ist kein neuer Commit (kein Hash), sondern stattdessen wir der Pointer von feature/1 einfach auf den letzten Commit von <code>main</code> gesetzt. Git erkennt, dass es keine √Ñnderungen auf <code>feature/1</code> gibt, die nicht auch auf <code>main</code> sind und somit <code>main</code> und <code>feature/1</code> identisch sind. Ein solcher Merge wird als Fast-Forward Merge bezeichnet.</p>
<blockquote>
<p>Fast Forwad Merges garantieren einen konfliktfreien Merge. Das bedeutet, dass es keine Merge-Konflikte geben kann.</p>
</blockquote>
<h1 id="merge-conflicts"><a class="header" href="#merge-conflicts">Merge Conflicts</a></h1>
<p>Im starken Kontrast zu Fast-Forward Merges stehen Merge Konflikte. Diese entstehen, wenn √Ñnderungen auf zwei Branches gemacht wurden, die sich gegenseitig widersprechen. Git ist dann nicht mehr in der Lage automatisch beide Dateien zusammenzuf√ºhren und ein manueller Eingriff ist erforderlich.</p>
<p>Unser Commit Tree schaut aktuell wie folgt aus.</p>
<pre><code class="language-mermaid">gitGraph

commit id: &quot;ae3f3d&quot;
branch feature/1
commit id: &quot;9ac33d&quot;
checkout main
commit id: &quot;782ca2&quot; type: HIGHLIGHT
</code></pre>
<p>Im ersten Commit (<code>ae3f3d</code>) haben wir die Datei foo.txt mit dem Inhalt <code>Hello World</code> erstellt. Im zweiten Commit (<code>9ac33d</code>, feature/1) haben wir die Datei foo.txt auf <code>Hello Alice!</code> ge√§ndert. Und auf <code>main</code> haben wir die Datei foo.txt auf <code>Hello Bob!</code> ge√§ndert.</p>
<pre><code class="language-bash"># == Urspr√ºnglich ==
$ git checkout ae3f3d
$ cat foo.txt
&gt; Hello World

# == main ==
$ git checkout main
$ cat foo.txt
&gt; Hello Alice!

# == feature/1 ==
$ git checkout feature/1
$ cat foo.txt
&gt; Hello Bob!
</code></pre>
<p>Wenn wir jetzt <code>feature/1</code> in <code>main</code> mergen wollen, wird es zwangsweise zu einem Merge-Konflikt kommen, da nicht klar ist ob es &quot;Hello Alice&quot; oder &quot;Hello Bob&quot; hei√üen soll.</p>
<pre><code class="language-bash">$ git checkout main
$ git merge feature/1
&gt; Auto-merging foo.txt
  CONFLICT (content): Merge conflict in foo.txt
  Automatic merge failed; fix conflicts and then commit the result.
</code></pre>
<p>Wie wir sehen, ist es zu einem Konflikt gekommen. Git hat versucht die Datei foo.txt automatisch zusammenzuf√ºhren, ist aber gescheitert. Es wurde somit auch noch kein Merge-Commit erstellt. Jediglich der Merge-Konflikt wurde in der Datei foo.txt markiert. Deshalb zeigt uns <code>git status</code> auch eine √Ñnderung an der Datei <code>foo.txt</code> an:</p>
<pre><code class="language-bash">$ git status
&gt; On branch main
  You have unmerged paths.
    (fix conflicts and run &quot;git commit&quot;)
    (use &quot;git merge --abort&quot; to abort the merge)

  Unmerged paths:
    (use &quot;git add &lt;file&gt;...&quot; to mark resolution)
	  both modified:   foo.txt

  no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)

</code></pre>
<p>Schauen wir uns mal an wie so ein Merge-Konflikt in der Datei aussieht:</p>
<pre><code class="language-bash">$ cat foo.txt
&gt; &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  Hello Alice!
  =======
  Hello Bob!
  &gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/1
</code></pre>
<p>Die Datei wurde in zwei Teile aufgeilt. Oben befindet sich immer der Stand von HEAD also in unserem Fall <code>main</code>. Ein <code>=======</code> trennt beide Teile. Unten befindet sich der Stand von <code>feature/1</code>. Um den Konflikt zu l√∂sen, m√ºssen wir die Datei so bearbeiten, dass sie nur noch den gew√ºnschten Stand enth√§lt und alle Konflikt-Markierungen entfernt sind. In unserem Fall wollen wir <code>Hello Alice!</code> und <code>Hello Bob!</code> zu <code>Hello Alice and Bob!</code> zusammenf√ºhren. Wir √§ndern das in unserem Editor und speichern die Datei. Jetzt schaut <code>foo.txt</code> so aus:</p>
<pre><code class="language-bash">$ cat foo.txt
&gt; Hello Alice and Bob!
</code></pre>
<p>Um git mitzuteilen, dass wir den Konflikt zu unserer Zufriedenheit gel√∂st haben, m√ºssen wir die Datei <code>foo.txt</code> mit <code>git add</code> der Staging Area hinzuf√ºgen und dann einen ganz normalen Commit erstellen.</p>
<pre><code class="language-bash">$ git add foo.txt
$ git commit -m &quot;Merge feature/1 into main&quot;
</code></pre>
<blockquote>
<p>Solltet ihr w√§hrend des Merge-Prozesses feststellen, dass ihr einen Fehler gemacht habt oder noch nicht bereit f√ºr den Merge seit, k√∂nnt ihr jederzeit den Merge mit <code>git merge --abort</code> abbrechen. Damit werden alle √Ñnderungen zur√ºckgestzt als ob der Merge nie angefangen wurde.</p>
</blockquote>
<p>Unser Commit Tree sieht jetzt wie ein normaler Merge aus:</p>
<pre><code class="language-mermaid">
gitGraph

commit id: &quot;ae3f3d&quot;
branch feature/1
commit id: &quot;9ac33d&quot;
checkout main
commit id: &quot;782ca2&quot;
merge feature/1 id: &quot;ac3e12&quot; type: HIGHLIGHT
</code></pre>
<p>Egal welche Art von Konflikt ihr in git habt, die L√∂sung folgt immer dem gleichen Schema:</p>
<ol>
<li>Konflikt in der Datei beheben und speichern</li>
<li><code>git add</code> um die Datei in die Staging Area zu legen</li>
<li>
<ul>
<li>F√ºr einen Merge-Konflikt einen Commit mit <code>git commit</code> erstellen.</li>
<li>F√ºr einen Rebase-Konflikt mit <code>git rebase --continue</code> fortfahren.</li>
</ul>
</li>
</ol>
<blockquote>
<p>Im Allgemeinen lohnt es sich immer den git Status abzufragen (<code>git status</code>). Hier werden alle notwendigen Schritte beschrieben um den Konflikt zu l√∂sen oder abbzubrechen.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rebasing"><a class="header" href="#rebasing">Rebasing</a></h1>
<p>Merging ist der einfachste Weg √Ñnderungen von einen auf einen anderen Branch zu √ºberf√ºhren. Jedoch gibt es in Git noch eine weitere M√∂glichkeit: Rebasing.
Im Gegensatz zum Merging werden beim Rebasing alle Commits des Quellbranches auf den Zielbranch √ºbertragen. Es wird also kein einziger Merge-Commit erstellt, sondern die Commits mitsamt deren √Ñnderungen werden von Quellbranch auf an den Zielbranch angeh√§ngt.</p>
<pre><code class="language-mermaid">gitGraph
  commit id: &quot;A&quot;
  branch feature/1
  commit id: &quot;B&quot;
  checkout main
  commit id: &quot;C&quot; type: HIGHLIGHT
  checkout feature/1
  commit id: &quot;D&quot;
</code></pre>
<pre><code class="language-bash">$ git checkout feature/1 # wir w√§hlen immer den Branch aus, den wir verschieben wollen
$ git rebase main
# oder
$ git rebase main feature/1
</code></pre>
<pre><code class="language-mermaid">gitGraph
  commit id: &quot;A&quot;
  commit id: &quot;C&quot;
  branch feature/1
  commit id: &quot;B'&quot;
  commit id: &quot;D'&quot; type: HIGHLIGHT
</code></pre>
<p>Achte insbesondere auf die Commit-IDs. Der Commit <code>B</code> wurde nicht einfach nur verschoben sondern neu auf <code>C</code> angewendet. Die Meta-Daten, aber nicht der Inhalt haben sich ver√§ndert. Das bedeutet, dass der Commit <code>B</code> eine neue Commit-ID <code>B'</code> bekommt. Nachdem <code>B</code> erfolgreich angewendet wurde, wird <code>D</code>auf <code>B'</code> angewendet und erh√§lt die neue Commit-ID <code>D'</code>.</p>
<p>Sollten wir wir main auf dem gleichen zusammengef√ºhrten Stand, wie <code>feature/1</code> haben wollen, k√∂nnen wir dies mit dem bereits bekannten Fast-Forward-Merge erreichen.</p>
<pre><code class="language-bash">$ git checkout main
$ git merge feature/1
</code></pre>
<pre><code class="language-mermaid">gitGraph
  commit id: &quot;A&quot;
  commit id: &quot;C&quot;
  branch feature/1
  commit id: &quot;B'&quot;
  commit id: &quot;D'&quot;
  checkout main
  merge feature/1 type: HIGHLIGHT
</code></pre>
<h2 id="rebase-konflikte"><a class="header" href="#rebase-konflikte">Rebase Konflikte</a></h2>
<p>Wie auch beim Merging kann es beim Rebasing zu Konflikten kommen. Wie wir diese l√∂sen k√∂nnen, hast du schon beim Merging gelernt. Nach Beheben und hinzuf√ºgen zur Staging Area, fahren wir mit <code>git rebase --continue</code> fort.</p>
<p>Wir sehen, dass wir keine neuen Commits erstellen (Es fehlt das <code>git commit</code> vom Merging). Stattdessen schreiben wir bereits vorhandene Commits um.</p>
<blockquote>
<p>Wie auch beim Merging k√∂nnen wir den Rebase-Vorgang mit <code>git rebase --abort</code> jederzeit abbrechen. Der Zustand vor Begin des Rebasings wird dann wieder hergestellt</p>
</blockquote>
<h1 id="rebase-vs-merge"><a class="header" href="#rebase-vs-merge">Rebase vs. Merge</a></h1>
<p>Rebase vs. Merge ist in der Git-Community so etwas wie eine Grundsatzdiskussion.
Das Merge-Lager argumentiert, dass Merge-Commits die Historie unver√§ndert abbilden und dass damit der Verlauf der Entwicklung durchgehend nachvollziehbar bleibt. Im Kontrast dazu ver√§ndert schreibt Rebasing die Historie um.</p>
<p>Die Rebase Anh√§nger sehen sich eher in der Perspektive von Autoren. Nicht der erste Entwurf ist immer gut nachvollziehar. Deshalb schreiben Sie die Geschichte im Nachhinein um, um sie f√ºr andere besser verst√§ndlich zu machen.</p>
<p>In der Praxis ist es eine Frage des pers√∂nlichen Geschmacks und des Projekts. F√ºr das Teamprojekt bietet sich vermutlich aber eine Kombination aus beiden an. Rebasing f√ºr den eigenen Branch bis Commits sehr einfach f√ºr andere Nachvollziehbar sind und Merging f√ºr das Zusammenf√ºhren von Feature-Branchen auf den Main-Branch.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changing-history"><a class="header" href="#changing-history">Changing History</a></h1>
<p>Sei es um die Historie besser nachvollziebar zu machen oder um Fehler zu korrigieren, es gibt immer wieder Situationen in denen wir die Historie √§ndern wollen.</p>
<h2 id="ver√§ndern-des-letzten-commits"><a class="header" href="#ver√§ndern-des-letzten-commits">Ver√§ndern des letzten Commits</a></h2>
<p>Ein Komma vergessen, vergessen die Datei zu formatieren oder einfach eine falsche Commit-Message geschrieben? Kein Problem wir k√∂nnen den letzten Commit ohne Probleme √§ndern. Eine M√∂glichkeit das zu erreichen haben wir uns bereits im Kapitel Resets angeschaut. Hierbei m√ºssen wir aber immer die Commit-Message komplett neu schreiben.</p>
<pre><code class="language-bash">   $ git reset --soft HEAD~
   # alle notwenigen √Ñnderungen vornehmen und der Staging Area hinzuf√ºgen
   $ git commit
</code></pre>
<p>Grade wenn wir nur kleine √Ñnderungen an der Commit Message vornehmen oder die Commit Message gleich bleiben soll, ist gibt es komfortablere M√∂glichkeiten.
Mit <code>git commit --amend</code> k√∂nnen wir den letzten Commit bearbeiten.</p>
<ol>
<li>F√ºge alle √Ñnderungen am letzten Commit der Staging Area hinzu.</li>
<li>
<pre><code class="language-bash">$ git commit --amend
</code></pre>
</li>
<li>Der Editor √∂ffnet sich und wir k√∂nnen die Commit-Message bearbeiten.</li>
<li>Speichern und schlie√üen</li>
</ol>
<h2 id="interaktive-rebase"><a class="header" href="#interaktive-rebase">Interaktive Rebase</a></h2>
<h3 id="bearbeiten-von-√§lteren-commits"><a class="header" href="#bearbeiten-von-√§lteren-commits">Bearbeiten von √§lteren Commits</a></h3>
<p>Wollen wir mehrere Commits oder Commits weiter aus der Vergangenheit bearbeiten m√ºssen wir zu einem komplexeren Tool greifen. Interaktives Rebasing
Eine abgespekte Form davon haben wir schon als normales Rebasing kennengelernt. Im Gegensatz zum normalen Rebasing, k√∂nnen wir hier aber die Reihenfolge der Commits √§ndern, Commits zusammenfassen oder auch Commits komplett l√∂schen.</p>
<p>In unserem Beispiel wollen wir die letzten 3 Commits bearbeiten.</p>
<pre><code class="language-bash">  $ git rebase -i HEAD~3
</code></pre>
<blockquote>
<p>Wie bei jedem git Befehlt k√∂nnen wir wahlweise auch direkt den Commit-Hash angeben.</p>
</blockquote>
<p>Sobald wir den Command ausf√ºhren √∂ffnet sich ein Editor mit einer Liste der letzten 3 Commits.</p>
<pre><code class="language-bash">pick 5c32ae1 Change my name a bit
pick 8723ace Update README formatting and hello world
pick a3b02e7 Add license

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
# p, pick &lt;commit&gt; = use commit
# r, reword &lt;commit&gt; = use commit, but edit the commit message
# e, edit &lt;commit&gt; = use commit, but stop for amending
# s, squash &lt;commit&gt; = use commit, but meld into previous commit
# f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit's log message
# x, exec &lt;command&gt; = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop &lt;commit&gt; = remove commit
# l, label &lt;label&gt; = label current HEAD with a name
# t, reset &lt;label&gt; = reset HEAD to a label
# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c &lt;commit&gt; to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre>
<p>Die Commits werden in inverser Reihenfolge zum Log angezeigt. Mit log w√ºrde die Reihenfolge wie folgt ausschauen:</p>
<pre><code class="language-bash">$ git log --oneline
a3b02e7 Add license
8723ace Update README formatting and hello world
5c32ae1 Change my name a bit
...
</code></pre>
<p>Der Editor vom interaktiven Rebase zeigt nicht die Vergangenheit unserere Commits, sondern ist vielmehr ein Skript, das von oben nach unten von git ausgef√ºhrt wird. Um eine √Ñnderung an einem Commit vorzunehmen, m√ºssen wir das skript √§ndern, sodass es anh√§lt und auf unsere Eingabe wartet. Um das zu erreichen, m√ºssen wir das <code>pick</code> durch ein <code>edit</code> ersetzten.</p>
<pre><code class="language-bash">edit 5c32ae1 Change my name a bit
pick 8723ace Update README formatting and hello world
pick a3b02e7 Add license
</code></pre>
<p>Wenn wir jetzt die Datei speichern und den Editor schlie√üen. Erhalten wir folgende ausgabe.</p>
<pre><code class="language-bash">$ git rebase -i HEAD~3
&gt; Stopped at f7f3f6d... Change my name a bit
  You can amend the commit now, with

       git commit --amend

  Once you're satisfied with your changes, run

       git rebase --continue
</code></pre>
<p>Wir k√∂nnen jetzt unsere √Ñnderungen stagen und wenn wir gl√ºcklich sind den Commit mit <code>git commit --amend</code> abschlie√üen. Hier ist dann auch nochmal die √Ñnderung der Commit-Message m√∂glich. Wenn du fertig bist, kannst du den Rebase mit <code>git rebase --continue</code> fortsetzten.</p>
<p>Da wir ansonsten alles auf <code>pick</code> gelassen haben, wird der Rest der Commits einfach angewendet.</p>
<blockquote>
<p>Grade bei gr√∂√üeren Rebases kann es zu Konflikten kommen. Diese m√ºssen dann wie bereits gelern h√§ndisch gel√∂st werden.</p>
</blockquote>
<blockquote>
<p>üí° Auch beim interaktiven Rebase gilt: Commits k√∂nnen nicht ver√§ndert werden. Was wir hier eigentlich machen ist das erstellen von neuen Commits, die die alten ersetzen.</p>
</blockquote>
<h3 id="umstellen-von-commits"><a class="header" href="#umstellen-von-commits">Umstellen von Commits</a></h3>
<p>Du hast den Eindruck, dass die Reihenfolge von Commits f√ºrs Verst√§ndnis nicht optional ist? Mit unserem Rebase ist das ein Katzensprung. Wie bei einem normalen Skript k√∂nnen wir die Reihenfolge der Befehle einfach √§ndern und die Reihenfolge der Commits √§ndert sich dementsprechend. Was als erstes kommt, wird auch als erstes angewendet.</p>
<h3 id="squashen-von-commits"><a class="header" href="#squashen-von-commits">Squashen von Commits</a></h3>
<p>Mit <code>git reset</code> haben wir schon eine M√∂glichkeit gesehen, wie wir Commits zusammenfassen k√∂nnen. Leider ging das dabei nur mit den letzten Commits bzw. bringt einen enormen Aufwand mit sich √§ltere Commits zusammenzufassen. Mit dem interaktiven Rebase ist das ganz schnell und elegant erledigt.</p>
<p>Hier nochmal unser Anfangszustand:</p>
<pre><code class="language-bash">pick 5c32ae1 Change my name a bit
pick 8723ace Update README formatting and hello world
pick a3b02e7 Add license
</code></pre>
<p>Wie unten im Editor in der hilfreichen Zusammenfassung beschrieben, k√∂nnen wir mit <code>squash</code> Commits zusammenfassen. Wichtig ist hierbei, dass wir der mit dem <code>squash</code> annotierte Commit mit dem Commit dar√ºber zusammengefasst wird. In unserem Beispiel wollen wir die ersten beiden Commits zusammenfassen:</p>
<pre><code class="language-bash">pick 5c32ae1 Change my name a bit
squash 8723ace Update README formatting and hello world
pick a3b02e7 Add license
</code></pre>
<p>Nachdem wir den Editor schlie√üen, √∂ffnet sich ein weiterer Editor, in dem wir die Commit-Message f√ºr den neuen (gesquashten) Commit eingeben k√∂nnen. Wenn wir fertig sind, speichern und schlie√üen wir den Editor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipps-und-tricks"><a class="header" href="#tipps-und-tricks">Tipps und Tricks</a></h1>
<h2 id="reflog-1"><a class="header" href="#reflog-1">Reflog!!</a></h2>
<p>Wir haben Reflog bereits <a href="git/./help.html">hier</a> ausf√ºhrlich besprochen. Es ist so ein lebensrettendes Tool, von dem viel zu wenige wissen, als dass wir es hier nicht nochmal erw√§hnen m√ºssen</p>
<h2 id="aliase"><a class="header" href="#aliase">Aliase</a></h2>
<p>Git Befehle sind k√∂nnen schnell zu sehr langen Monstern mit vielen Optionen ausaten. Und selbst wenn sie nur mittellang sind und wir sie sehr oft eingeben m√ºssen ist das l√§stig. Hier kommen Aliase ins Spiel. Mit ihnen k√∂nnen wir Befehle abk√ºrzen. Wir k√∂nnen sie entweder global f√ºr alle Projekte oder nur f√ºr das aktuelle Projekt definieren.
Hier ein paar Beispiele:</p>
<pre><code class="language-bash">$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
</code></pre>
<p>Wirklich angenehm sind Aliase wenn wir Befehle erstellen wollen die eigentlich exisieren sollen. Warum nicht einfach <code>git unstage</code> statt <code>git reset HEAD</code></p>
<pre><code class="language-bash">$ git config --global alias.unstage 'reset HEAD'
$ git config --global alias.graph 'log --oneline --graph'
</code></pre>
<p>Unser Leben wird deutlich angenehmer wenn wir uns ein paar Aliase erstellen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remotes"><a class="header" href="#remotes">Remotes</a></h1>
<p>Bis jetzt haben wir uns sehr viel mit lokaler Version History besch√§ftigt und du hast nahezu alles gelernt was man braucht um git zu meistern. Bis jetzt haben wir aber gits Konzept zur Kollaboration mit anderen noch nicht angesprochen. Das ist der Punkt an dem Remotes ins Spiel kommen.</p>
<h2 id="wir-und-der-server"><a class="header" href="#wir-und-der-server">Wir und der Server</a></h2>
<p>Das klassische Client-Modell sollte jedem sein Begriff sein. Mehrere Clients greifen auf einen Server zu. Der Server ist der zentrale Punkt an dem alle Clients ihre Daten ablegen und abrufen. Git verfolgt hier einen √§hnlichen Ansatz. Der Server ist in diesem Fall ein Remote Repository und die Clients sind unsere lokalen Repositories. Aber wie k√∂nnen wir diese beiden miteinander kombinieren?</p>
<h2 id="remote-branches"><a class="header" href="#remote-branches">Remote Branches</a></h2>
<p>Branches kennen wir ja bereits sehr gut. Mit ihren k√∂nnen wir unsere Arbeit in verschiedene Richtungen aufteilen und sp√§ter wieder zusammenf√ºhren. Grade das Zusammenf√ºhren ist f√ºr uns jetzt wichtig. Wir wollen unsere Arbeit mit der Arbeit anderer zusammenf√ºhren. Klingt vertraut? Das ist genau das was wir mit Merging und Rebasing gemacht haben. Der Server ist f√ºr uns also nichts weiter als weitere Branches auf die wir unsere Arbeit zusammenf√ºhren k√∂nnen.</p>
<p>Anders als unsere lokalen Branches arbeiten wir auf unseren Remote Branches nicht mit <code>git commit</code> sondern mit <code>git push</code> und <code>git pull</code>. Aber lass uns das erstmal Konzeptuell verstehen.</p>
<p>Am Anfang haben wir ein remote Repository (z.B. auf Github). Wir clone dieses und schaffen damit automatisch eine Verkn√ºfung zwischen remote und local repository. Diese Verkn√ºpfung wird standartm√§√üig als <code>origin</code> bezeichnet, kann aber einen beliebigen Namen haben. Mit <code>git remote</code> k√∂nnen wir uns alle Remote Verkn√ºfungen anzeigen lassen.</p>
<pre><code class="language-bash">$ git remote
&gt; origin
</code></pre>
<p>Bei unserem Repsository gibt es eine Verkn√ºpfung names <code>origin</code>.</p>
<blockquote>
<p>Sollten wir nicht mehr wissen wo ein Remote hinzeigt, k√∂nnten wir das und noch mehr mit <code>git remote show &lt;remote_verkn√ºfung&gt;</code> anzeigen lassen. F√ºr <code>origin</code> w√§re das <code>git remote show origin</code>.</p>
</blockquote>
<p>Zus√§tzlich hat unser Repository zwei Branches: <code>main</code> und <code>origin/main</code>. Der Branch <code>main</code> ist unser lokaler Branch und <code>origin/main</code> ist ein Remote Branch, der den Stand des Branches <code>main</code> auf dem Server wiederspiegelt.
Nach einem <code>git clone</code> sind beide Branches auf dem gleichen Stand.</p>
<p>Client:</p>
<pre><code class="language-mermaid">gitGraph
  commit id: &quot; &quot;
  branch origin/main
  commit id: &quot;A &quot;
  commit id: &quot;B &quot;
  commit id: &quot;C &quot;

  checkout main
  merge origin/main
</code></pre>
<p>Server:</p>
<pre><code class="language-mermaid">%%{init: { 'gitGraph': { 'mainBranchName': 'origin/main' }} }%%
gitGraph
  commit id: &quot;A&quot;
  commit id: &quot;B&quot;
  commit id: &quot;C&quot;
</code></pre>
<p>Soweit so einfach. Da Server und Client nicht immer auf dem gleichen Stand sind, kann es passieren, dass beide schnell auseinander driften. Wenn der Server einen neuen Commit bekommt wird unser Remote Branch <code>origin/main</code> nicht automatisch aktualisiert. Das m√ºssen wir manuell mit <code>git fetch</code> machen.</p>
<p>Wenn der Server einen neuen Commit bekommt und wir <code>git fetch</code> ausf√ºhren sieht danach unser Repository so aus:</p>
<pre><code class="language-bash">$ git fetch origin main:main
</code></pre>
<blockquote>
<p><code>origin main:main</code> ist ein bischen viel auf einmal. <code>origin</code> ist der Name der Verkn√ºpfung auf die wir uns beziehen. Das erste <code>main</code> ist der Name des Branches auf dem Server den wir fetchen wollen und das zweite <code>main</code> ist der Name des Branches in unserem lokalen Repository in dem wir den Branch speichern wollen.</p>
</blockquote>
<p>Client:</p>
<pre><code class="language-mermaid">gitGraph
  commit id: &quot; &quot;
  branch origin/main
  commit id: &quot;A &quot;
  commit id: &quot;B &quot;
  commit id: &quot;C &quot;

  checkout main
  merge origin/main
  checkout origin/main
  commit id: &quot;D&quot;
</code></pre>
<p>Server:</p>
<pre><code class="language-mermaid">%%{init: { 'gitGraph': { 'mainBranchName': 'origin/main' }} }%%
gitGraph
  commit id: &quot;A&quot;
  commit id: &quot;B&quot;
  commit id: &quot;C&quot;
  commit id: &quot;D&quot;
</code></pre>
<p>Auf main selber sind die √Ñnderungen noch nicht angekommen. Das m√ºssen wir manuell machen. Daf√ºr gibt es zwei M√∂glichkeiten: Das klassische <code>git merge</code> oder das etwas komplexere <code>git rebase</code>. Beide Methoden kennst du bereits.
Wir entscheiden uns hier f√ºr das einfache <code>git merge</code></p>
<pre><code class="language-bash">$ git checkout main
$ git merge origin/main
</code></pre>
<p>Client:</p>
<pre><code class="language-mermaid">gitGraph
  commit id: &quot; &quot;
  branch origin/main
  commit id: &quot;A &quot;
  commit id: &quot;B &quot;
  commit id: &quot;C &quot;

  checkout main
  merge origin/main
  checkout origin/main
  commit id: &quot;D&quot;
  checkout main
  merge origin/main
</code></pre>
<p>Server:</p>
<pre><code class="language-mermaid">%%{init: { 'gitGraph': { 'mainBranchName': 'origin/main' }} }%%
gitGraph
  commit id: &quot;A&quot;
  commit id: &quot;B&quot;
  commit id: &quot;C&quot;
  commit id: &quot;D&quot;
</code></pre>
<p>Da dieser Vorgang sehr h√§ufig vorkommt git bietet git eine Abk√ºrzung an: <code>git pull</code>. <code>git pull</code> f√ºhrt <code>git fetch</code> und <code>git merge</code> in einem Schritt aus.</p>
<pre><code class="language-bash">$ git pull origin main:main
</code></pre>
<p>So kommen wir deutlich simpler zum gleichen Ergebnis.</p>
<blockquote>
<p>Sollten wir bereits einen Upstream f√ºr diesen Branch gesetzt haben, k√∂nnen wir auch einfach <code>git pull</code> ohne <code>origin main</code> ausf√ºhren. Zur Upstream sp√§ter mehr</p>
</blockquote>
<p>Nun zum √úbertragen von Commits auf den Server. Erstellen wir daf√ºr zun√§chst einen neuen Commit auf unserem Client.</p>
<pre><code class="language-bash">$ git commit
</code></pre>
<p>Client:</p>
<pre><code class="language-mermaid">gitGraph
  commit id: &quot; &quot;
  branch origin/main
  commit id: &quot;A &quot;
  commit id: &quot;B &quot;
  commit id: &quot;C &quot;

  checkout main
  merge origin/main
  checkout origin/main
  commit id: &quot;D&quot;
  checkout main
  merge origin/main
  commit id: &quot;E&quot;
</code></pre>
<p>Server:</p>
<pre><code class="language-mermaid">%%{init: { 'gitGraph': { 'mainBranchName': 'origin/main' }} }%%
gitGraph
  commit id: &quot;A&quot;
  commit id: &quot;B&quot;
  commit id: &quot;C&quot;
  commit id: &quot;D&quot;
</code></pre>
<p>Wollen wir diesen Commit auf den Server √ºbertragen, m√ºssen wir zun√§chst sicherstellen, dass wir auf dem neusten Stand vom Server sind. Sollte das nicht der Fall sein, m√ºssen wir erst einen <code>git pull</code> durchf√ºhren. Damit wird sichergestellt, dass wir beim Pushen keine Konflikte verursachen und ein Fast-Forward-Merge auf dem Server durchgef√ºhrt werden kann.</p>
<pre><code class="language-bash">$ git pull origin main:main
&gt; Already up to date.
$ git push origin main:main
</code></pre>
<blockquote>
<p><code>git push origin main:main</code> ist ein wenig anders als bei <code>git fetch</code> oder <code>git pull</code>. Zwar ist <code>origin</code> wieder der Name der Verkn√ºpfung, aber das erste <code>main</code> steht hier f√ºr den lokalen Branch und das zweite <code>main</code> steht f√ºr den Branch auf dem Server. Von links nach rechts folgt es also der Reihenfolge der Operation. F√ºr <code>push</code> : lokal -&gt; remote f√ºr <code>fetch</code> und <code>pull</code> : remote -&gt; lokal</p>
</blockquote>
<p>Der Push-Vorgang setzt zun√§chst den Remote Branch auf den Stand unseres lokalen Branches und √ºbertragt dann seine √Ñnderungen auf den Server.</p>
<p>Client:</p>
<pre><code class="language-mermaid">gitGraph
  commit id: &quot; &quot;
  branch origin/main
  commit id: &quot;A &quot;
  commit id: &quot;B &quot;
  commit id: &quot;C &quot;

  checkout main
  merge origin/main
  checkout origin/main
  commit id: &quot;D&quot;
  checkout main
  merge origin/main
  commit id: &quot;E&quot;
  checkout origin/main
  merge main
</code></pre>
<p>Server:</p>
<pre><code class="language-mermaid">%%{init: { 'gitGraph': { 'mainBranchName': 'origin/main' }} }%%
gitGraph
  commit id: &quot;A&quot;
  commit id: &quot;B&quot;
  commit id: &quot;C&quot;
  commit id: &quot;D&quot;
  commit id: &quot;E&quot;
</code></pre>
<h1 id="upstreams"><a class="header" href="#upstreams">Upstreams</a></h1>
<p>Das ganze Prozedere mit <code>origin main:main</code> ist ein wenig umst√§ndlich. Deshalb l√§sst sich dies auch einmalig f√ºr einen Branch festlegen und danach einfach ein <code>git pull</code> bzw. <code>git push</code> ausf√ºhren. Wir checken daf√ºr zun√§chst den gew√ºnschten Branch aus und setzen den Upstream mit <code>git branch --set-upstream-to=&lt;remote&gt;/branch</code>.</p>
<p>F√ºr den Branch <code>main</code> auf dem Server sieht das so aus:</p>
<pre><code class="language-bash">$ git checkout main
$ git branch --set-upstream-to=origin/main
# oder k√ºrzer
$ git checkout main
$ git branch -u origin/main
</code></pre>
<blockquote>
<p>Bei einem Clone wird der Upstream automatisch f√ºr den Branch gesetzt. Das hei√üt f√ºr ein geclontes Repository ist <code>git pull</code> und <code>git push</code> ohne weiteres f√ºr <code>main</code> m√∂glich.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cheatsheet"><a class="header" href="#cheatsheet">Cheatsheet</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="softwareentwicklung"><a class="header" href="#softwareentwicklung">Softwareentwicklung</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
